import { StrokeOptions } from 'perfect-freehand';

interface Unsubscribe {
  (): void
}

declare type DrawingMode = 'draw' | 'stylus' | 'line' | 'rectangle' | 'ellipse' | 'eraseLine';
interface Brush {
    /**
     * @default 'brush'
     */
    mode?: DrawingMode;
    /**
     * Stroke color
     */
    color: string;
    /**
     * Stroke width
     */
    size: number;
    /**
     * Color filled, only works in `rectangle` and `ellipse` mode.
     * @default 'transparent'
     */
    fill?: string;
    /**
     * Pattern of dashes, set to `undefined` for solid line.
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray
     */
    dasharray?: string;
    /**
     * Corner radius of the rectangle.
     * Works only in `rectangle` mode.
     *
     * @default 0
     */
    cornerRadius?: number;
    /**
     * Show an arrow at the end of the line.
     * Works only in `draw` and `line` mode.
     *
     * @default false
     */
    arrowEnd?: boolean;
    /**
     * Options for 'perfect-freehand'
     */
    stylusOptions?: StrokeOptions;
}
interface Point {
    x: number;
    y: number;
    pressure?: number;
}
interface Options {
    el?: string | SVGSVGElement;
    brush?: Brush;
    /**
     * Filter out events based on input type
     *
     * @default ['mouse', 'touch', 'pen']
     */
    acceptsInputTypes?: ('mouse' | 'touch' | 'pen')[];
    /**
     * Use different element to listen on the events
     *
     * @default the `el` option
     */
    eventTarget?: string | Element;
    /**
     * When you apply a scale transform to the svg container,
     * set this property to let drauu aware of the currect coordinates.
     * @default 1
     */
    coordinateScale?: number;
    /**
     * Apply SVG CTM transform when calculating the coordinates.
     *
     * @advanced you don't commonly need this
     * @default true
     */
    coordinateTransform?: boolean;
}
interface EventsMap {
    start: () => void;
    end: () => void;
    committed: (node: SVGElement | undefined) => void;
    canceled: () => void;
    changed: () => void;
    mounted: () => void;
    unmounted: () => void;
}

declare abstract class BaseModel<T extends SVGElement> {
    protected drauu: Drauu;
    event: PointerEvent;
    point: Point;
    start: Point;
    el: T | null;
    constructor(drauu: Drauu);
    onSelected(el: SVGSVGElement | null): void;
    onUnselected(): void;
    onStart(point: Point): SVGElement | undefined;
    onMove(point: Point): boolean;
    onEnd(point: Point): SVGElement | boolean | undefined;
    get brush(): Brush;
    get shiftPressed(): boolean;
    get altPressed(): boolean;
    get svgElement(): SVGSVGElement | null;
    getMousePosition(event: PointerEvent): Point;
    protected createElement<K extends keyof SVGElementTagNameMap>(name: K, overrides?: Partial<Brush>): SVGElementTagNameMap[K];
    protected attr(name: string, value: string | number): void;
    private _setEvent;
    /**
     * @internal
     */
    _eventDown(event: PointerEvent): SVGElement | undefined;
    /**
     * @internal
     */
    _eventMove(event: PointerEvent): boolean;
    /**
     * @internal
     */
    _eventUp(event: PointerEvent): boolean | SVGElement | undefined;
}

declare class Drauu {
    options: Options;
    el: SVGSVGElement | null;
    svgPoint: DOMPoint | null;
    eventEl: Element | null;
    shiftPressed: boolean;
    altPressed: boolean;
    drawing: boolean;
    private _emitter;
    private _models;
    private _currentNode;
    private _undoStack;
    private _disposables;
    constructor(options?: Options);
    get model(): BaseModel<SVGElement>;
    get mounted(): boolean;
    get mode(): DrawingMode;
    set mode(v: DrawingMode);
    get brush(): Brush;
    set brush(v: Brush);
    resolveSelector<T>(selector: string | T | null | undefined): T | null;
    mount(el: string | SVGSVGElement, eventEl?: string | Element): void;
    unmount(): void;
    on<K extends keyof EventsMap>(type: K, fn: EventsMap[K]): Unsubscribe;
    undo(): boolean;
    redo(): boolean;
    canRedo(): boolean;
    canUndo(): boolean;
    private eventMove;
    private eventStart;
    private eventEnd;
    private acceptsInput;
    private eventKeyboard;
    private commit;
    clear(): void;
    cancel(): void;
    dump(): string;
    load(svg: string): void;
}
declare function createDrauu(options?: Options): Drauu;

export { Brush, Drauu, DrawingMode, EventsMap, Options, Point, createDrauu };
