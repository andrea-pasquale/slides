{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["/* eslint-disable prefer-spread, no-regex-spaces, no-unused-vars, guard-for-in, no-console, no-var */\n// @flow\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n */\n\n// Flow Type Definitions:\n\ntype Capture =\n    | (Array<string> & {index: number})\n    | (Array<string> & {index?: number});\n\ntype Attr = string | number | boolean | null | void;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any,\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {\n    key?: string | number | void,\n    inline?: ?boolean,\n    [string]: any,\n};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = {regex?: RegExp} & ((\n    source: string,\n    state: State,\n    prevCapture: string,\n) => ?Capture);\n\ntype Parser = (source: string, state?: ?State) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode | ASTNode;\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (node: ASTNode, state?: ?State) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State,\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State,\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule,\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n};\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule &\n    TextReactOutputRule &\n    NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule &\n    NonNullReactOutputRule &\n    NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule &\n    ElementReactOutputRule &\n    NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>,\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +tableSeparator: DefaultInRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n    alt?: string,\n};\n\n// End Flow Definitions\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n\n/**\n * Turn various whitespace into easy-to-process whitespace\n */\nvar preprocess = function (source: string): string {\n    return source\n        .replace(CR_NEWLINE_R, \"\\n\")\n        .replace(FORMFEED_R, \"\")\n        .replace(TAB_R, \"    \");\n};\n\nvar populateInitialState = function (\n    givenState: ?State,\n    defaultState: ?State,\n): State {\n    var state: State = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            // $FlowFixMe\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function (rules: ParserRules, defaultState: ?State): Parser {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function (type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if (\n            (typeof order !== \"number\" || !isFinite(order)) &&\n            typeof console !== \"undefined\"\n        ) {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" +\n                    type +\n                    \"`: \" +\n                    String(order),\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function (typeA, typeB) {\n        var ruleA: ParserRule = (rules[typeA]: any);\n        var ruleB: ParserRule = (rules[typeB]: any);\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n            // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    var latestState: State;\n    var nestedParse: Parser = function (\n        source: string,\n        state: ?State,\n    ): Array<SingleASTNode> {\n        var result: Array<SingleASTNode> = [];\n        state = state || latestState;\n        latestState = state;\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n\n            // $FlowFixMe\n            var currRule: ParserRule = rules[currRuleType];\n\n            do {\n                var currOrder = currRule.order;\n                var prevCaptureStr =\n                    state.prevCapture == null ? \"\" : state.prevCapture[0];\n                var currCapture = currRule.match(source, state, prevCaptureStr);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality\n                        ? currRule.quality(currCapture, state, prevCaptureStr)\n                        : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                // $FlowFixMe\n                currRule = rules[currRuleType];\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule &&\n                // if we don't have a match yet, continue\n                (!capture ||\n                    // or if we have a match, but the next rule is\n                    // at the same order, and has a quality measurement\n                    // functions, then this rule must have a quality\n                    // measurement function (since they are sorted before\n                    // those without), and we need to check if there is\n                    // a better quality match\n                    (currRule.order === currOrder && currRule.quality))\n            );\n\n            // TODO(aria): Write tests for these\n            if (rule == null || capture == null) {\n                throw new Error(\n                    \"Could not find a matching rule for the below \" +\n                        \"content. The rule with highest `order` should \" +\n                        \"always match content provided to it. Check \" +\n                        \"the definition of `match` for '\" +\n                        ruleList[ruleList.length - 1] +\n                        \"'. It seems to not match the following source:\\n\" +\n                        source,\n                );\n            }\n            if (capture.index) {\n                // If present and non-zero, i.e. a non-^ regexp result:\n                throw new Error(\n                    \"`match` must return a capture starting at index 0 \" +\n                        \"(the current parse index). Did you forget a ^ at the \" +\n                        \"start of the RegExp?\",\n                );\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                // $FlowFixMe\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                if (parsed == null || typeof parsed !== \"object\") {\n                    throw new Error(\n                        `parse() function returned invalid parse result: '${parsed}'`,\n                    );\n                }\n\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    // $FlowFixMe\n                    parsed.type = ruleType;\n                }\n                result.push(parsed);\n            }\n\n            state.prevCapture = capture;\n            source = source.substring(state.prevCapture[0].length);\n        }\n\n        // $FlowFixMe\n        return result;\n    };\n\n    var outerParse: Parser = function (\n        source: string,\n        state: ?State,\n    ): Array<SingleASTNode> {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information). This stores\n        // the full regex capture object, if there is one.\n        latestState.prevCapture = null;\n        return nestedParse(preprocess(source), latestState);\n    };\n\n    // $FlowFixMe\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\nvar inlineRegex = function (regex: RegExp): MatchFunction {\n    var match = function (\n        source: string,\n        state: State,\n        prevCapture: string,\n    ): ?Capture {\n        if (state.inline) {\n            // $FlowFixMe\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\nvar blockRegex = function (regex: RegExp): MatchFunction {\n    // $FlowFixMe\n    var match: MatchFunction = function (source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\nvar anyScopeRegex = function (regex: RegExp): MatchFunction {\n    // $FlowFixMe\n    var match: MatchFunction = function (source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === \"function\" &&\n        Symbol.for &&\n        Symbol.for(\"react.element\")) ||\n    0xeac7;\n\nvar reactElement = function (\n    type: string,\n    key: string | number | null | void,\n    props: {[string]: any},\n): ReactElement {\n    var element: ReactElement = ({\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key == null ? undefined : key,\n        ref: null,\n        props: props,\n        _owner: null,\n    }: any);\n    return element;\n};\n\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\nvar htmlTag = function (\n    tagName: string,\n    content: string,\n    attributes: ?{[any]: ?Attr},\n    isClosed: ?boolean,\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== \"undefined\" ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (\n            // $FlowFixMe\n            Object.prototype.hasOwnProperty.call(attributes, attr) &&\n            attribute\n        ) {\n            attributeString +=\n                \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\nvar sanitizeUrl = function (url: ?string) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = new URL(url, \"https://localhost\").protocol;\n        if (\n            prot.indexOf(\"javascript:\") === 0 ||\n            prot.indexOf(\"vbscript:\") === 0 ||\n            prot.indexOf(\"data:\") === 0\n        ) {\n            return null;\n        }\n    } catch (e) {\n        // invalid URLs should throw a TypeError\n        // see for instance: `new URL(\"\");`\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    \"&\": \"&amp;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#96;\",\n};\n\nvar sanitizeText = function (text: Attr): string {\n    return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function (rawUrlString: string): string {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n */\nvar parseInline = function (\n    parse: Parser,\n    content: string,\n    state: State,\n): ASTNode {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseBlock = function (\n    parse: Parser,\n    content: string,\n    state: State,\n): ASTNode {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseCaptureInline = function (\n    capture: Capture,\n    parse: Parser,\n    state: State,\n): UnTypedASTNode {\n    return {\n        content: parseInline(parse, capture[1], state),\n    };\n};\n\nvar ignoreCapture = function (): UnTypedASTNode {\n    return {};\n};\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n        \"[^\\\\n]*(?:\\\\n\" +\n        \"(?!\\\\1\" +\n        LIST_BULLET +\n        \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\",\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" +\n        LIST_BULLET +\n        \") \" +\n        \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n        \"(?!\\\\1\" +\n        LIST_BULLET +\n        \" )\\\\n*\" +\n        // the \\\\s*$ here is so that we can parse the inside of nested\n        // lists, where our content might end before we receive two `\\n`s\n        \"|\\\\s*\\n*$)\",\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function () {\n    // predefine regexes so we don't have to create them inside functions\n    // sure, regex literals should be fast, even inside functions, but they\n    // aren't in all browsers.\n    var TABLE_BLOCK_TRIM = /\\n+/g;\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    // TODO: This needs a real type\n    type TableAlignment = any;\n\n    var parseTableAlignCapture = function (\n        alignCapture: string,\n    ): TableAlignment {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    var parseTableAlign = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<TableAlignment> {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    var parseTableRow = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<Array<SingleASTNode>> {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        var cells = [[]];\n        tableRow.forEach(function (node, i) {\n            if (node.type === \"tableSeparator\") {\n                // Filter out empty table separators at the start/end:\n                if (\n                    !trimEndSeparators ||\n                    (i !== 0 && i !== tableRow.length - 1)\n                ) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (\n                    node.type === \"text\" &&\n                    (tableRow[i + 1] == null ||\n                        tableRow[i + 1].type === \"tableSeparator\")\n                ) {\n                    node.content = node.content.replace(\n                        TABLE_CELL_END_TRIM,\n                        \"\",\n                    );\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<Array<ASTNode>> {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function (rowText) {\n            // $FlowFixMe\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function (trimEndSeparators) {\n        return function (capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(\n                capture[1],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            var align = parseTableAlign(\n                capture[2],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            var cells = parseTableCells(\n                capture[3],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells,\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX:\n            /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX:\n            /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n    \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function (\n    capture: Capture,\n    state: State,\n    refNode: RefNode,\n): RefNode {\n    var ref = (capture[2] || capture[1]).replace(/\\s+/g, \" \").toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\n\nvar defaultRules: DefaultRules = {\n    Array: {\n        react: function (arr, output, state) {\n            var oldKey = state.key;\n            var result: Array<ReactElements> = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = \"\" + i;\n\n                var node = arr[i];\n                if (node.type === \"text\") {\n                    node = {type: \"text\", content: node.content};\n                    for (\n                        ;\n                        i + 1 < arr.length && arr[i + 1].type === \"text\";\n                        i++\n                    ) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function (arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++) {\n                var node = arr[i];\n                if (node.type === \"text\") {\n                    node = {type: \"text\", content: node.content};\n                    for (\n                        ;\n                        i + 1 < arr.length && arr[i + 1].type === \"text\";\n                        i++\n                    ) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        },\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2].trim(), state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"h\" + node.level, state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        },\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null,\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === \"=\" ? 1 : 2,\n                content: parseInline(parse, capture[1], state),\n            };\n        },\n        react: null,\n        html: null,\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return reactElement(\"hr\", state.key, EMPTY_PROPS);\n        },\n        html: function (node, output, state) {\n            return \"<hr>\";\n        },\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            var content = capture[0].replace(/^    /gm, \"\").replace(/\\n+$/, \"\");\n            return {\n                lang: undefined,\n                content: content,\n            };\n        },\n        react: function (node, output, state) {\n            var className = node.lang\n                ? \"markdown-code-\" + node.lang\n                : undefined;\n\n            return reactElement(\"pre\", state.key, {\n                children: reactElement(\"code\", null, {\n                    className: className,\n                    children: node.content,\n                }),\n            });\n        },\n        html: function (node, output, state) {\n            var className = node.lang\n                ? \"markdown-code-\" + node.lang\n                : undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className,\n            });\n            return htmlTag(\"pre\", codeBlock);\n        },\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(\n            /^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/,\n        ),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function (capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, \"\");\n            return {\n                content: parse(content, state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"blockquote\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        },\n    },\n    list: {\n        order: currOrder++,\n        // $FlowFixMe\n        match: function (source, state) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var prevCaptureStr =\n                state.prevCapture == null ? \"\" : state.prevCapture[0];\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function (capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items: Array<string> = capture[0]\n                .replace(LIST_BLOCK_END_R, \"\\n\")\n                .match(LIST_ITEM_R);\n\n            // We know this will match here, because of how the regexes are\n            // defined\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function (item: string, i: number) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                    // remove indents on trailing lines:\n                    .replace(spaceRegex, \"\")\n                    // remove the bullet:\n                    .replace(LIST_ITEM_PREFIX_R, \"\");\n\n                // I'm not sur4 why this is necessary again?\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = i === items.length - 1;\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph =\n                    containsBlocks || (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent,\n            };\n        },\n        react: function (node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(ListWrapper, state.key, {\n                start: node.start,\n                children: node.items.map(function (item: ASTNode, i: number) {\n                    return reactElement(\"li\", \"\" + i, {\n                        children: output(item, state),\n                    });\n                }),\n            });\n        },\n        html: function (node, output, state) {\n            var listItems = node.items\n                .map(function (item: ASTNode) {\n                    return htmlTag(\"li\", output(item, state));\n                })\n                .join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start,\n            };\n            return htmlTag(listTag, listItems, attributes);\n        },\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/,\n        ),\n        parse: function (capture, parse, state) {\n            var def = capture[1].replace(/\\s+/g, \" \").toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function (refNode: RefNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function () {\n            return null;\n        },\n        html: function () {\n            return \"\";\n        },\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function (node, output, state) {\n            var getStyle = function (colIndex: number): {\n                [attr: string]: Attr,\n            } {\n                return node.align[colIndex] == null\n                    ? {}\n                    : {\n                          textAlign: node.align[colIndex],\n                      };\n            };\n\n            var headers = node.header.map(function (\n                content: ASTNode,\n                i: number,\n            ) {\n                return reactElement(\"th\", \"\" + i, {\n                    style: getStyle(i),\n                    scope: \"col\",\n                    children: output(content, state),\n                });\n            });\n\n            var rows = node.cells.map(function (\n                row: Array<ASTNode>,\n                r: number,\n            ) {\n                return reactElement(\"tr\", \"\" + r, {\n                    children: row.map(function (content: ASTNode, c: number) {\n                        return reactElement(\"td\", \"\" + c, {\n                            style: getStyle(c),\n                            children: output(content, state),\n                        });\n                    }),\n                });\n            });\n\n            return reactElement(\"table\", state.key, {\n                children: [\n                    reactElement(\"thead\", \"thead\", {\n                        children: reactElement(\"tr\", null, {\n                            children: headers,\n                        }),\n                    }),\n                    reactElement(\"tbody\", \"tbody\", {\n                        children: rows,\n                    }),\n                ],\n            });\n        },\n        html: function (node, output, state) {\n            var getStyle = function (colIndex: number): string {\n                return node.align[colIndex] == null\n                    ? \"\"\n                    : \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header\n                .map(function (content: ASTNode, i: number) {\n                    return htmlTag(\"th\", output(content, state), {\n                        style: getStyle(i),\n                        scope: \"col\",\n                    });\n                })\n                .join(\"\");\n\n            var rows = node.cells\n                .map(function (row: Array<ASTNode>) {\n                    var cols = row\n                        .map(function (content: ASTNode, c: number) {\n                            return htmlTag(\"td\", output(content, state), {\n                                style: getStyle(c),\n                            });\n                        })\n                        .join(\"\");\n\n                    return htmlTag(\"tr\", cols);\n                })\n                .join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        },\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return \"\\n\";\n        },\n        html: function (node, output, state) {\n            return \"\\n\";\n        },\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"div\", state.key, {\n                className: \"paragraph\",\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                class: \"paragraph\",\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        },\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    tableSeparator: {\n        order: currOrder++,\n        // $FlowFixMe\n        match: function (source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function () {\n            return {type: \"tableSeparator\"};\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function () {\n            return \" | \";\n        },\n        html: function () {\n            return \" &vert; \";\n        },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: capture[1],\n                    },\n                ],\n                target: capture[1],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function (capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: address,\n                    },\n                ],\n                target: target,\n            };\n        },\n        react: null,\n        html: null,\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: capture[1],\n                    },\n                ],\n                target: capture[1],\n                title: undefined,\n            };\n        },\n        react: null,\n        html: null,\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            var link = {\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3],\n            };\n            return link;\n        },\n        react: function (node, output, state) {\n            return reactElement(\"a\", state.key, {\n                href: sanitizeUrl(node.target),\n                title: node.title,\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title,\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        },\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                \"^!\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\\\\(\" +\n                    LINK_HREF_AND_TITLE +\n                    \"\\\\)\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3],\n            };\n            return image;\n        },\n        react: function (node, output, state) {\n            return reactElement(\"img\", state.key, {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title,\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title,\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        },\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                // The first [part] of the link\n                \"^\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\" +\n                    // The [ref] target of the link\n                    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state),\n            });\n        },\n        react: null,\n        html: null,\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                // The first [part] of the link\n                \"^!\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\" +\n                    // The [ref] target of the link\n                    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1],\n            });\n        },\n        react: null,\n        html: null,\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                    \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                    \"\\\\b\" +\n                    // Or match *s:\n                    \"|\" +\n                    // Only match *s that are followed by a non-space:\n                    \"^\\\\*(?=\\\\S)(\" +\n                    // Match at least one of:\n                    \"(?:\" +\n                    //  - `**`: so that bolds inside italics don't close the\n                    //          italics\n                    \"\\\\*\\\\*|\" +\n                    //  - escape sequence: so escaped *s don't close us\n                    \"\\\\\\\\[\\\\s\\\\S]|\" +\n                    //  - whitespace: followed by a non-* (we don't\n                    //          want ' *' to close an italics--it might\n                    //          start a list)\n                    \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                    //  - non-whitespace, non-*, non-backslash characters\n                    \"[^\\\\s\\\\*\\\\\\\\]\" +\n                    \")+?\" +\n                    // followed by a non-space, non-* then *\n                    \")\\\\*(?!\\\\*)\",\n            ),\n        ),\n        quality: function (capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function (capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"em\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        },\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function (capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"strong\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        },\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function (capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"u\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        },\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(\n            /^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/,\n        ),\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"del\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        },\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function (capture, parse, state) {\n            return {\n                content: capture[2].replace(\n                    INLINE_CODE_ESCAPE_BACKTICKS_R,\n                    \"$1\",\n                ),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"code\", state.key, {\n                children: node.content,\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        },\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return reactElement(\"br\", state.key, EMPTY_PROPS);\n        },\n        html: function (node, output, state) {\n            return \"<br>\";\n        },\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/,\n        ),\n        parse: function (capture, parse, state) {\n            return {\n                content: capture[0],\n            };\n        },\n        react: function (node, output, state) {\n            return node.content;\n        },\n        html: function (node, output, state) {\n            return sanitizeText(node.content);\n        },\n    },\n};\n\n/** (deprecated) */\nvar ruleOutput = function (\n    // $FlowFixMe\n    rules: OutputRules<Rule>,\n    property: $Keys<Rule>,\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\n            \"simple-markdown ruleOutput should take 'react' or \" +\n                \"'html' as the second argument.\",\n        );\n    }\n\n    var nestedRuleOutput = function (\n        ast: SingleASTNode,\n        outputFunc: Output<any>,\n        state: State,\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\n/** (deprecated)\n */\nvar reactFor = function (outputFunc: ReactNodeOutput): ReactOutput {\n    var nestedOutput: ReactOutput = function (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result: Array<ReactElements> = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = \"\" + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (\n                    typeof nodeOut === \"string\" &&\n                    typeof lastResult === \"string\"\n                ) {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/** (deprecated)\n */\nvar htmlFor = function (outputFunc: HtmlNodeOutput): HtmlOutput {\n    var nestedOutput: HtmlOutput = function (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast\n                .map(function (node) {\n                    return nestedOutput(node, state);\n                })\n                .join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar outputFor = function (\n    rules: OutputRules<Rule>,\n    property: $Keys<Rule>,\n    defaultState: ?State = {},\n) {\n    if (!property) {\n        throw new Error(\n            \"simple-markdown: outputFor: `property` must be \" +\n                \"defined. \" +\n                \"if you just upgraded, you probably need to replace `outputFor` \" +\n                \"with `reactFor`\",\n        );\n    }\n\n    var latestState: State;\n    // $FlowFixMe[incompatible-type]\n    var arrayRule: ArrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n        throw new Error(\n            \"simple-markdown: outputFor: to join nodes of type `\" +\n                property +\n                \"` you must provide an `Array:` joiner rule with that type, \" +\n                \"Please see the docs for details on specifying an Array rule.\",\n        );\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    var nestedOutput: Output<any> = function (ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRuleOutput(ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    var outerOutput: Output<any> = function (ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\n// $FlowFixMe[incompatible-call]\nvar defaultRawParse = parserFor(defaultRules);\n\nvar defaultBlockParse = function (\n    source: string,\n    state: ?State,\n): Array<SingleASTNode> {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\n\nvar defaultInlineParse = function (\n    source: string,\n    state: ?State,\n): Array<SingleASTNode> {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\n\nvar defaultImplicitParse = function (\n    source: string,\n    state: ?State,\n): Array<SingleASTNode> {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\n// $FlowFixMe[incompatible-call]\nvar defaultReactOutput: ReactOutput = outputFor(defaultRules, \"react\");\n// $FlowFixMe[incompatible-call]\nvar defaultHtmlOutput: HtmlOutput = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function (source: string, state: ?State): ReactElements {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n\nvar markdownToHtml = function (source: string, state: ?State): string {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\n// TODO: This needs definition\ntype ReactMarkdownProps = any;\nvar ReactMarkdown = function (props: ReactMarkdownProps): ReactElement {\n    var divProps = {};\n\n    for (var prop in props) {\n        if (\n            prop !== \"source\" &&\n            // $FlowFixMe\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\"div\", null, divProps);\n};\n\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule: Object>(\n        rules: OutputRules<Rule>,\n        param: $Keys<Rule>,\n        defaultState?: ?State,\n    ) => Output<any>,\n\n    +ruleOutput: <Rule: Object>(\n        rules: OutputRules<Rule>,\n        param: $Keys<Rule>,\n    ) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: {source: string, [string]: any}) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (\n        source: string,\n        state?: ?State,\n    ) => Array<SingleASTNode>,\n    +defaultInlineParse: (\n        source: string,\n        state?: ?State,\n    ) => Array<SingleASTNode>,\n    +defaultImplicitParse: (\n        source: string,\n        state?: ?State,\n    ) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (\n        tagName: string,\n        content: string,\n        attributes: ?{[any]: ?Attr},\n        isClosed: ?boolean,\n    ) => string,\n    +reactElement: (\n        type: string,\n        key: string | null,\n        props: {[string]: any},\n    ) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n    SingleASTNode,\n};\n\n// $FlowFixMe\nvar SimpleMarkdown: Exports = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function () {\n        if (typeof console !== \"undefined\") {\n            console.warn(\n                \"defaultParse is deprecated, please use `defaultImplicitParse`\",\n            );\n        }\n        return defaultImplicitParse.apply(null, (arguments: any));\n    },\n    defaultOutput: function () {\n        if (typeof console !== \"undefined\") {\n            console.warn(\n                \"defaultOutput is deprecated, please use `defaultReactOutput`\",\n            );\n        }\n        return defaultReactOutput.apply(null, (arguments: any));\n    },\n};\n\nexport default SimpleMarkdown;\n"],"names":["CR_NEWLINE_R","TAB_R","FORMFEED_R","preprocess","source","replace","populateInitialState","givenState","defaultState","state","prop","Object","prototype","hasOwnProperty","call","parserFor","rules","ruleList","keys","filter","type","rule","match","order","isFinite","console","warn","String","sort","typeA","typeB","ruleA","ruleB","orderA","orderB","secondaryOrderA","quality","secondaryOrderB","latestState","nestedParse","result","ruleType","capture","NaN","i","currRuleType","currRule","currOrder","prevCaptureStr","prevCapture","currCapture","currQuality","Error","length","index","parsed","parse","Array","isArray","push","apply","substring","outerParse","inline","disableAutoBlockNewlines","inlineRegex","regex","exec","blockRegex","anyScopeRegex","TYPE_SYMBOL","Symbol","for","reactElement","key","props","element","$$typeof","undefined","ref","_owner","htmlTag","tagName","content","attributes","isClosed","attributeString","attr","attribute","sanitizeText","unclosedTag","EMPTY_PROPS","sanitizeUrl","url","prot","URL","protocol","indexOf","e","SANITIZE_TEXT_R","SANITIZE_TEXT_CODES","text","chr","UNESCAPE_URL_R","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","parseBlock","parseCaptureInline","ignoreCapture","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","RegExp","LIST_ITEM_R","BLOCK_END_R","INLINE_CODE_ESCAPE_BACKTICKS_R","LIST_BLOCK_END_R","LIST_ITEM_END_R","LIST_R","LIST_LOOKBEHIND_R","TABLES","TABLE_ROW_SEPARATOR_TRIM","TABLE_CELL_END_TRIM","TABLE_RIGHT_ALIGN","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","parseTableAlignCapture","alignCapture","test","parseTableAlign","trimEndSeparators","alignText","trim","split","map","parseTableRow","prevInTable","inTable","tableRow","cells","forEach","node","parseTableCells","rowsText","rowText","parseTable","header","align","parseNpTable","TABLE_REGEX","NPTABLE_REGEX","LINK_INSIDE","LINK_HREF_AND_TITLE","AUTOLINK_MAILTO_CHECK_R","parseRef","refNode","toLowerCase","_defs","def","target","title","_refs","defaultRules","react","arr","output","oldKey","html","heading","level","children","nptable","lheading","hr","codeBlock","lang","className","class","fence","blockQuote","list","isStartOfLineCapture","isListBlock","_list","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","item","prefixCapture","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","ListWrapper","listItems","join","listTag","table","getStyle","colIndex","textAlign","headers","style","scope","rows","row","r","c","cols","thead","tbody","newline","paragraph","escape","tableSeparator","autolink","mailto","address","link","href","image","alt","src","reflink","refimage","em","strong","u","del","inlineCode","br","ruleOutput","property","nestedRuleOutput","ast","outputFunc","reactFor","nestedOutput","lastResult","nodeOut","htmlFor","outputFor","arrayRule","arrayRuleCheck","arrayRuleOutput","outerOutput","defaultRawParse","defaultBlockParse","defaultInlineParse","defaultImplicitParse","isBlock","defaultReactOutput","defaultHtmlOutput","markdownToReact","markdownToHtml","ReactMarkdown","divProps","SimpleMarkdown","defaultParse","arguments","defaultOutput"],"mappings":"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"}