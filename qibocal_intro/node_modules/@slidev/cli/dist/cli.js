"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }










var _chunkZWPKUGOZjs = require('./chunk-ZWPKUGOZ.js');



var _chunkUL7Y3R6Sjs = require('./chunk-UL7Y3R6S.js');


var _chunkGE7W2DBEjs = require('./chunk-GE7W2DBE.js');

// node/cli.ts
var import_fast_deep_equal = _chunkGE7W2DBEjs.__toESM.call(void 0, _chunkUL7Y3R6Sjs.require_fast_deep_equal.call(void 0, ));
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _os = require('os'); var _os2 = _interopRequireDefault(_os);
var _child_process = require('child_process');
var _readline = require('readline'); var readline = _interopRequireWildcard(_readline);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _open = require('open'); var _open2 = _interopRequireDefault(_open);
var _yargs = require('yargs'); var _yargs2 = _interopRequireDefault(_yargs);
var _prompts = require('prompts'); var _prompts2 = _interopRequireDefault(_prompts);
var _kolorist = require('kolorist');
var _isinstalledglobally = require('is-installed-globally'); var _isinstalledglobally2 = _interopRequireDefault(_isinstalledglobally);
var _parser = require('@slidev/parser');
var _fs = require('@slidev/parser/fs');
var _getportplease = require('get-port-please');
var CONFIG_RESTART_FIELDS = [
  "highlighter",
  "monaco",
  "routerMode",
  "fonts",
  "css"
];
_fs.injectPreparserExtensionLoader.call(void 0, async (headmatter, filepath) => {
  const addons = _nullishCoalesce((headmatter == null ? void 0 : headmatter.addons), () => ( []));
  const roots = (
    /* uniq */
    [
      _chunkZWPKUGOZjs.getUserRoot.call(void 0, {}).userRoot,
      ..._chunkZWPKUGOZjs.getAddonRoots.call(void 0, addons, ""),
      _chunkZWPKUGOZjs.getClientRoot.call(void 0, )
    ]
  );
  const mergeArrays = (a, b) => a.concat(b);
  return await _chunkUL7Y3R6Sjs.loadSetups.call(void 0, roots, "preparser.ts", { filepath, headmatter }, [], false, mergeArrays);
});
var cli = _yargs2.default.scriptName("slidev").usage("$0 [args]").version(_chunkZWPKUGOZjs.version).strict().showHelpOnFail(false).alias("h", "help").alias("v", "version");
cli.command(
  "* [entry]",
  "Start a local server for Slidev",
  (args) => commonOptions(args).option("port", {
    alias: "p",
    type: "number",
    describe: "port"
  }).option("open", {
    alias: "o",
    default: false,
    type: "boolean",
    describe: "open in browser"
  }).option("remote", {
    type: "string",
    describe: "listen public host and enable remote control"
  }).option("tunnel", {
    default: false,
    type: "boolean",
    describe: "open localtunnel to make Slidev available on the internet"
  }).option("log", {
    default: "warn",
    type: "string",
    choices: ["error", "warn", "info", "silent"],
    describe: "log level"
  }).option("inspect", {
    default: false,
    type: "boolean",
    describe: "enable the inspect plugin for debugging"
  }).option("force", {
    alias: "f",
    default: false,
    type: "boolean",
    describe: "force the optimizer to ignore the cache and re-bundle  "
  }).strict().help(),
  async ({ entry, theme, port: userPort, open, log, remote, tunnel, force, inspect }) => {
    if (!_fsextra2.default.existsSync(entry) && !entry.endsWith(".md"))
      entry = `${entry}.md`;
    if (!_fsextra2.default.existsSync(entry)) {
      const { create } = await _prompts2.default.call(void 0, {
        name: "create",
        type: "confirm",
        initial: "Y",
        message: `Entry file ${_kolorist.yellow.call(void 0, `"${entry}"`)} does not exist, do you want to create it?`
      });
      if (create)
        await _fsextra2.default.copyFile(_path2.default.resolve(__dirname, "../template.md"), entry);
      else
        process.exit(0);
    }
    let server;
    let port = 3030;
    let lastRemoteUrl;
    async function initServer() {
      if (server)
        await server.close();
      const options = await _chunkZWPKUGOZjs.resolveOptions.call(void 0, { entry, remote, theme, inspect }, "dev");
      port = userPort || await findFreePort(3030);
      server = await _chunkZWPKUGOZjs.createServer.call(void 0, 
        options,
        {
          server: {
            port,
            strictPort: true,
            open,
            host: remote !== void 0 ? "0.0.0.0" : "localhost",
            force
          },
          logLevel: log
        },
        {
          onDataReload(newData, data) {
            if (!theme && _chunkZWPKUGOZjs.resolveThemeName.call(void 0, newData.config.theme) !== _chunkZWPKUGOZjs.resolveThemeName.call(void 0, data.config.theme)) {
              console.log(_kolorist.yellow.call(void 0, "\n  restarting on theme change\n"));
              initServer();
            } else if (CONFIG_RESTART_FIELDS.some((i) => !(0, import_fast_deep_equal.default)(newData.config[i], data.config[i]))) {
              console.log(_kolorist.yellow.call(void 0, "\n  restarting on config change\n"));
              initServer();
            }
          }
        }
      );
      await server.listen();
      let tunnelUrl = "";
      if (tunnel) {
        if (remote != null)
          tunnelUrl = await openTunnel(port);
        else
          console.log(_kolorist.yellow.call(void 0, "\n  --remote is required for tunneling, localtunnel is not enabled.\n"));
      }
      lastRemoteUrl = printInfo(options, port, remote, tunnelUrl);
    }
    async function openTunnel(port2) {
      const localtunnel = await Promise.resolve().then(() => require("localtunnel")).then((r) => r.default || r);
      const tunnel2 = await localtunnel({
        port: port2,
        local_host: "0.0.0.0"
      });
      return tunnel2.url;
    }
    const SHORTCUTS = [
      {
        name: "r",
        fullname: "restart",
        action() {
          initServer();
        }
      },
      {
        name: "o",
        fullname: "open",
        action() {
          _open2.default.call(void 0, `http://localhost:${port}`);
        }
      },
      {
        name: "e",
        fullname: "edit",
        action() {
          _child_process.exec.call(void 0, `code "${entry}"`);
        }
      },
      {
        name: "c",
        fullname: "qrcode",
        async action() {
          if (!lastRemoteUrl)
            return;
          const qrcode = await Promise.resolve().then(() => require("qrcode-terminal")).then((r) => r.default || r);
          qrcode.generate(lastRemoteUrl, { small: true }, (v) => {
            console.log(`
${_kolorist.dim.call(void 0, "  QR Code for remote control: ")}
  ${_kolorist.blue.call(void 0, lastRemoteUrl)}
`);
            console.log(v.split("\n").map((i) => `  ${i}`).join("\n"));
          });
        }
      }
    ];
    function bindShortcut() {
      process.stdin.resume();
      process.stdin.setEncoding("utf8");
      readline.emitKeypressEvents(process.stdin);
      if (process.stdin.isTTY)
        process.stdin.setRawMode(true);
      process.stdin.on("keypress", (str, key) => {
        if (key.ctrl && key.name === "c") {
          process.exit();
        } else {
          const [sh] = SHORTCUTS.filter((item) => item.name === str);
          if (sh) {
            try {
              sh.action();
            } catch (err) {
              console.error(`Failed to execute shortcut ${sh.fullname}`, err);
            }
          }
        }
      });
    }
    initServer();
    bindShortcut();
  }
);
cli.command(
  "build [entry..]",
  "Build hostable SPA",
  (args) => exportOptions(commonOptions(args)).option("watch", {
    alias: "w",
    default: false,
    describe: "build watch"
  }).option("out", {
    alias: "o",
    type: "string",
    default: "dist",
    describe: "output dir"
  }).option("base", {
    type: "string",
    describe: "output base"
  }).option("download", {
    alias: "d",
    type: "boolean",
    describe: "allow download as PDF"
  }).option("inspect", {
    default: false,
    type: "boolean",
    describe: "enable the inspect plugin for debugging"
  }).strict().help(),
  async (args) => {
    const { entry, theme, watch, base, download, out, inspect } = args;
    const { build } = await Promise.resolve().then(() => require("./build-OCDEV4EW.js"));
    for (const entryFile of entry) {
      const options = await _chunkZWPKUGOZjs.resolveOptions.call(void 0, { entry: entryFile, theme, inspect }, "build");
      if (download && !options.data.config.download)
        options.data.config.download = download;
      printInfo(options);
      await build(options, {
        base,
        build: {
          watch: watch ? {} : void 0,
          outDir: entry.length === 1 ? out : _path2.default.join(out, _path2.default.basename(entryFile, ".md"))
        }
      }, { ...args, entry: entryFile });
    }
  }
);
cli.command(
  "format [entry..]",
  "Format the markdown file",
  (args) => commonOptions(args).strict().help(),
  async ({ entry }) => {
    for (const entryFile of entry) {
      const data = await _chunkZWPKUGOZjs.parser.load(entryFile);
      _chunkZWPKUGOZjs.parser.prettify(data);
      await _chunkZWPKUGOZjs.parser.save(data);
    }
  }
);
cli.command(
  "theme [subcommand]",
  "Theme related operations",
  (command) => {
    return command.command(
      "eject",
      "Eject current theme into local file system",
      (args) => commonOptions(args).option("dir", {
        type: "string",
        default: "theme"
      }),
      async ({ entry, dir, theme: themeInput }) => {
        const data = await _chunkZWPKUGOZjs.parser.load(entry);
        const theme = _chunkZWPKUGOZjs.resolveThemeName.call(void 0, themeInput || data.config.theme);
        if (theme === "none") {
          console.error('Cannot eject theme "none"');
          process.exit(1);
        }
        if (_chunkZWPKUGOZjs.isPath.call(void 0, theme)) {
          console.error("Theme is already ejected");
          process.exit(1);
        }
        const roots = _chunkZWPKUGOZjs.getThemeRoots.call(void 0, theme, entry);
        if (!roots.length) {
          console.error(`Could not find theme "${theme}"`);
          process.exit(1);
        }
        const root = roots[0];
        await _fsextra2.default.copy(root, _path2.default.resolve(dir), {
          filter: (i) => !/node_modules|.git/.test(_path2.default.relative(root, i))
        });
        const dirPath = `./${dir}`;
        data.slides[0].frontmatter.theme = dirPath;
        data.slides[0].raw = null;
        await _chunkZWPKUGOZjs.parser.save(data);
        console.log(`Theme "${theme}" ejected successfully to "${dirPath}"`);
      }
    );
  },
  () => {
    cli.showHelp();
    process.exit(1);
  }
);
cli.command(
  "export [entry..]",
  "Export slides to PDF",
  (args) => exportOptions(commonOptions(args)).strict().help(),
  async (args) => {
    const { entry, theme } = args;
    process.env.NODE_ENV = "production";
    const { exportSlides, getExportOptions } = await Promise.resolve().then(() => require("./export-GTPZJWVE.js"));
    const port = await findFreePort(12445);
    for (const entryFile of entry) {
      const options = await _chunkZWPKUGOZjs.resolveOptions.call(void 0, { entry: entryFile, theme }, "export");
      const server = await _chunkZWPKUGOZjs.createServer.call(void 0, 
        options,
        {
          server: { port },
          clearScreen: false
        }
      );
      await server.listen(port);
      printInfo(options);
      _chunkZWPKUGOZjs.parser.filterDisabled(options.data);
      const result = await exportSlides({
        port,
        ...getExportOptions({ ...args, entry: entryFile }, options)
      });
      console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${result}
`);
      server.close();
    }
    process.exit(0);
  }
);
cli.command(
  "export-notes [entry..]",
  "Export slide notes to PDF",
  (args) => args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("output", {
    type: "string",
    describe: "path to the output"
  }).option("timeout", {
    default: 3e4,
    type: "number",
    describe: "timeout for rendering the print page"
  }).strict().help(),
  async ({
    entry,
    output,
    timeout
  }) => {
    process.env.NODE_ENV = "production";
    const { exportNotes } = await Promise.resolve().then(() => require("./export-GTPZJWVE.js"));
    const port = await findFreePort(12445);
    for (const entryFile of entry) {
      const options = await _chunkZWPKUGOZjs.resolveOptions.call(void 0, { entry: entryFile }, "export");
      const server = await _chunkZWPKUGOZjs.createServer.call(void 0, 
        options,
        {
          server: { port },
          clearScreen: false
        }
      );
      await server.listen(port);
      printInfo(options);
      _chunkZWPKUGOZjs.parser.filterDisabled(options.data);
      const result = await exportNotes({
        port,
        output: output || (options.data.config.exportFilename ? `${options.data.config.exportFilename}-notes` : `${_path2.default.basename(entryFile, ".md")}-export-notes`),
        timeout
      });
      console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${result}
`);
      server.close();
    }
    process.exit(0);
  }
);
cli.help().parse();
function commonOptions(args) {
  return args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("theme", {
    alias: "t",
    type: "string",
    describe: "override theme"
  });
}
function exportOptions(args) {
  return args.option("output", {
    type: "string",
    describe: "path to the output"
  }).option("format", {
    type: "string",
    choices: ["pdf", "png", "md"],
    describe: "output format"
  }).option("timeout", {
    type: "number",
    describe: "timeout for rendering the print page"
  }).option("range", {
    type: "string",
    describe: 'page ranges to export, for example "1,4-5,6"'
  }).option("dark", {
    type: "boolean",
    describe: "export as dark theme"
  }).option("with-clicks", {
    alias: "c",
    type: "boolean",
    describe: "export pages for every clicks"
  }).option("executable-path", {
    type: "string",
    describe: "executable to override playwright bundled browser"
  }).option("with-toc", {
    type: "boolean",
    describe: "export pages with outline"
  }).option("per-slide", {
    type: "boolean",
    describe: "slide slides slide by slide. Works better with global components, but will break cross slide links and TOC in PDF"
  });
}
function printInfo(options, port, remote, tunnelUrl) {
  console.log();
  console.log();
  console.log(`  ${_kolorist.cyan.call(void 0, "\u25CF") + _kolorist.blue.call(void 0, "\u25A0") + _kolorist.yellow.call(void 0, "\u25B2")}`);
  console.log(`${_kolorist.bold.call(void 0, "  Slidev")}  ${_kolorist.blue.call(void 0, `v${_chunkZWPKUGOZjs.version}`)} ${_isinstalledglobally2.default ? _kolorist.yellow.call(void 0, "(global)") : ""}`);
  console.log();
  console.log(_kolorist.dim.call(void 0, "  theme   ") + (options.theme ? _kolorist.green.call(void 0, options.theme) : _kolorist.gray.call(void 0, "none")));
  console.log(_kolorist.dim.call(void 0, "  entry   ") + _kolorist.dim.call(void 0, _path2.default.dirname(options.entry) + _path2.default.sep) + _path2.default.basename(options.entry));
  if (port) {
    const query = remote ? `?password=${remote}` : "";
    const presenterPath = `${options.data.config.routerMode === "hash" ? "/#/" : "/"}presenter/${query}`;
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  public slide show ")}  > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/`)}`);
    if (query)
      console.log(`${_kolorist.dim.call(void 0, "  private slide show ")} > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/${query}`)}`);
    console.log(`${_kolorist.dim.call(void 0, "  presenter mode ")}     > ${_kolorist.blue.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}${presenterPath}`)}`);
    if (options.inspect)
      console.log(`${_kolorist.dim.call(void 0, "  inspector")}           > ${_kolorist.yellow.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/__inspect/`)}`);
    let lastRemoteUrl = "";
    if (remote !== void 0) {
      Object.values(_os2.default.networkInterfaces()).forEach(
        (v) => (v || []).filter((details) => String(details.family).slice(-1) === "4" && !details.address.includes("127.0.0.1")).forEach(({ address }) => {
          lastRemoteUrl = `http://${address}:${port}${presenterPath}`;
          console.log(`${_kolorist.dim.call(void 0, "  remote control ")}     > ${_kolorist.blue.call(void 0, lastRemoteUrl)}`);
        })
      );
      if (tunnelUrl) {
        lastRemoteUrl = `${tunnelUrl}${presenterPath}`;
        console.log(`${_kolorist.dim.call(void 0, "  remote via tunnel")}   > ${_kolorist.yellow.call(void 0, lastRemoteUrl)}`);
      }
    } else {
      console.log(`${_kolorist.dim.call(void 0, "  remote control ")}     > ${_kolorist.dim.call(void 0, "pass --remote to enable")}`);
    }
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  shortcuts ")}          > ${_kolorist.underline.call(void 0, "r")}${_kolorist.dim.call(void 0, "estart | ")}${_kolorist.underline.call(void 0, "o")}${_kolorist.dim.call(void 0, "pen | ")}${_kolorist.underline.call(void 0, "e")}${_kolorist.dim.call(void 0, "dit")}${lastRemoteUrl ? ` | ${_kolorist.dim.call(void 0, "qr")}${_kolorist.underline.call(void 0, "c")}${_kolorist.dim.call(void 0, "ode")}` : ""}`);
    return lastRemoteUrl;
  }
  console.log();
  _parser.verifyConfig.call(void 0, options.data.config, options.data.themeMeta, (v) => console.warn(_kolorist.yellow.call(void 0, `  ! ${v}`)));
  console.log();
}
async function findFreePort(start) {
  if (await _getportplease.checkPort.call(void 0, start) !== false)
    return start;
  return findFreePort(start + 1);
}
