"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }








var _chunkGE7W2DBEjs = require('./chunk-GE7W2DBE.js');

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = _chunkGE7W2DBEjs.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node/common.ts
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);
var _path = require('path');
var _utils = require('@antfu/utils');
var _vite = require('vite');
async function getIndexHtml({ clientRoot, themeRoots, addonRoots, data, userRoot }) {
  var _a, _b;
  let main = await _fs.promises.readFile(_path.join.call(void 0, clientRoot, "index.html"), "utf-8");
  let head = "";
  let body = "";
  head += `<link rel="icon" href="${data.config.favicon}">`;
  const roots = _utils.uniq.call(void 0, [
    ...themeRoots,
    ...addonRoots,
    userRoot
  ]);
  for (const root of roots) {
    const path = _path.join.call(void 0, root, "index.html");
    if (!_fs.existsSync.call(void 0, path))
      continue;
    const index = await _fs.promises.readFile(path, "utf-8");
    head += `
${(((_a = index.match(/<head>([\s\S]*?)<\/head>/im)) == null ? void 0 : _a[1]) || "").trim()}`;
    body += `
${(((_b = index.match(/<body>([\s\S]*?)<\/body>/im)) == null ? void 0 : _b[1]) || "").trim()}`;
  }
  if (data.features.tweet)
    body += '\n<script async src="https://platform.twitter.com/widgets.js"></script>';
  if (data.config.fonts.webfonts.length && data.config.fonts.provider !== "none")
    head += `
<link rel="stylesheet" href="${_chunkGE7W2DBEjs.generateGoogleFontsUrl.call(void 0, data.config.fonts)}" type="text/css">`;
  main = main.replace("__ENTRY__", _chunkGE7W2DBEjs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}
async function mergeViteConfigs({ addonRoots, themeRoots }, viteConfig, config, command) {
  const configEnv = {
    mode: "development",
    command
  };
  const files = _utils.uniq.call(void 0, [
    ...themeRoots,
    ...addonRoots
  ]).map((i) => _path.join.call(void 0, i, "vite.config.ts"));
  for await (const file of files) {
    if (!_fs.existsSync.call(void 0, file))
      continue;
    const viteConfig2 = await _vite.loadConfigFromFile.call(void 0, configEnv, file);
    if (!(viteConfig2 == null ? void 0 : viteConfig2.config))
      continue;
    config = _vite.mergeConfig.call(void 0, config, viteConfig2.config);
  }
  return _vite.mergeConfig.call(void 0, viteConfig, config);
}

// node/plugins/setupNode.ts

var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);

var _jiti = require('jiti'); var _jiti2 = _interopRequireDefault(_jiti);
function deepMerge(a, b, rootPath = "") {
  a = { ...a };
  Object.keys(b).forEach((key) => {
    if (_utils.isObject.call(void 0, a[key]))
      a[key] = deepMerge(a[key], b[key], rootPath ? `${rootPath}.${key}` : key);
    else if (Array.isArray(a[key]))
      a[key] = [...a[key], ...b[key]];
    else
      a[key] = b[key];
  });
  return a;
}
async function loadSetups(roots, name, arg, initial, merge = true, accumulate) {
  let returns = initial;
  for (const root of roots) {
    const path = _path.resolve.call(void 0, root, "setup", name);
    if (await _fsextra.pathExists.call(void 0, path)) {
      const { default: setup } = _jiti2.default.call(void 0, __filename)(path);
      const result = await setup(arg);
      if (result !== null) {
        returns = merge ? deepMerge(returns, result) : accumulate ? accumulate(returns, result) : result;
      }
    }
  }
  return returns;
}

// node/plugins/windicss.ts




async function createWindiCSSPlugin({ themeRoots, addonRoots, clientRoot, userRoot, roots, data }, { windicss: windiOptions }) {
  const { default: WindiCSS } = await Promise.resolve().then(() => require("vite-plugin-windicss"));
  const { defaultConfigureFiles } = await Promise.resolve().then(() => require("@windicss/config"));
  const configFiles = _utils.uniq.call(void 0, [
    ...defaultConfigureFiles.map((i) => _path.resolve.call(void 0, userRoot, i)),
    ...themeRoots.map((i) => `${i}/windi.config.ts`),
    ...addonRoots.map((i) => `${i}/windi.config.ts`),
    _path.resolve.call(void 0, clientRoot, "windi.config.ts")
  ]);
  const configFile = configFiles.find((i) => _fs.existsSync.call(void 0, i));
  let config = _jiti2.default.call(void 0, __filename)(configFile);
  if (config.default)
    config = config.default;
  config = await loadSetups(roots, "windicss.ts", {}, config, true);
  return WindiCSS(
    {
      configFiles: [configFile],
      config,
      onConfigResolved(config2) {
        if (!config2.theme)
          config2.theme = {};
        if (!config2.theme.extend)
          config2.theme.extend = {};
        if (!config2.theme.extend.fontFamily)
          config2.theme.extend.fontFamily = {};
        const fontFamily = config2.theme.extend.fontFamily;
        fontFamily.sans || (fontFamily.sans = data.config.fonts.sans.join(","));
        fontFamily.mono || (fontFamily.mono = data.config.fonts.mono.join(","));
        fontFamily.serif || (fontFamily.serif = data.config.fonts.serif.join(","));
        return config2;
      },
      onOptionsResolved(config2) {
        themeRoots.forEach((i) => {
          config2.scanOptions.include.push(`${i}/components/**/*.{vue,ts}`);
          config2.scanOptions.include.push(`${i}/layouts/**/*.{vue,ts}`);
        });
        addonRoots.forEach((i) => {
          config2.scanOptions.include.push(`${i}/components/**/*.{vue,ts}`);
          config2.scanOptions.include.push(`${i}/layouts/**/*.{vue,ts}`);
        });
        config2.scanOptions.include.push(`!${_utils.slash.call(void 0, _path.resolve.call(void 0, userRoot, "node_modules"))}`);
        config2.scanOptions.exclude.push(_path.dirname.call(void 0, _chunkGE7W2DBEjs.resolveImportPath.call(void 0, "monaco-editor/package.json", true)));
        config2.scanOptions.exclude.push(_path.dirname.call(void 0, _chunkGE7W2DBEjs.resolveImportPath.call(void 0, "katex/package.json", true)));
        config2.scanOptions.exclude.push(_path.dirname.call(void 0, _chunkGE7W2DBEjs.resolveImportPath.call(void 0, "prettier/package.json", true)));
      },
      ...windiOptions
    }
  );
}

// node/plugins/preset.ts


var _pluginvue = require('@vitejs/plugin-vue'); var _pluginvue2 = _interopRequireDefault(_pluginvue);
var _pluginvuejsx = require('@vitejs/plugin-vue-jsx'); var _pluginvuejsx2 = _interopRequireDefault(_pluginvuejsx);
var _vite3 = require('unplugin-icons/vite'); var _vite4 = _interopRequireDefault(_vite3);
var _resolver = require('unplugin-icons/resolver'); var _resolver2 = _interopRequireDefault(_resolver);
var _vite5 = require('unplugin-vue-components/vite'); var _vite6 = _interopRequireDefault(_vite5);
var _vitepluginremoteassets = require('vite-plugin-remote-assets'); var _vitepluginremoteassets2 = _interopRequireDefault(_vitepluginremoteassets);
var _vitepluginvueserverref = require('vite-plugin-vue-server-ref'); var _vitepluginvueserverref2 = _interopRequireDefault(_vitepluginvueserverref);

var _viteplugininspect = require('vite-plugin-inspect'); var _viteplugininspect2 = _interopRequireDefault(_viteplugininspect);
var _vitepluginstaticcopy = require('vite-plugin-static-copy');

// node/drawings.ts


var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
function resolveDrawingsDir(options) {
  return options.data.config.drawings.persist ? _path.resolve.call(void 0, 
    _path.dirname.call(void 0, options.entry),
    options.data.config.drawings.persist
  ) : void 0;
}
async function loadDrawings(options) {
  const dir = resolveDrawingsDir(options);
  if (!dir || !_fsextra2.default.existsSync(dir))
    return {};
  const files = await _fastglob2.default.call(void 0, "*.svg", {
    onlyFiles: true,
    cwd: dir,
    absolute: true,
    suppressErrors: true
  });
  const obj = {};
  await Promise.all(files.map(async (path) => {
    const num = +_path.basename.call(void 0, path, ".svg");
    if (Number.isNaN(num))
      return;
    const content = await _fsextra2.default.readFile(path, "utf8");
    const lines = content.split(/\n/g);
    obj[num.toString()] = lines.slice(1, -1).join("\n");
  }));
  return obj;
}
async function writeDrawings(options, drawing) {
  const dir = resolveDrawingsDir(options);
  if (!dir)
    return;
  const width = options.data.config.canvasWidth;
  const height = Math.round(width / options.data.config.aspectRatio);
  const SVG_HEAD = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">`;
  await _fsextra2.default.ensureDir(dir);
  return Promise.all(
    Object.entries(drawing).map(async ([key, value]) => {
      if (!value)
        return;
      const svg = `${SVG_HEAD}
${value}
</svg>`;
      await _fsextra2.default.writeFile(_path.join.call(void 0, dir, `${key}.svg`), svg, "utf-8");
    })
  );
}

// node/plugins/extendConfig.ts


var _isinstalledglobally = require('is-installed-globally'); var _isinstalledglobally2 = _interopRequireDefault(_isinstalledglobally);


// ../client/package.json
var dependencies = {
  "@antfu/utils": "^0.7.2",
  "@slidev/parser": "workspace:*",
  "@slidev/types": "workspace:*",
  "@unocss/reset": "^0.51.5",
  "@vueuse/core": "^10.0.2",
  "@vueuse/head": "^1.1.26",
  "@vueuse/math": "^10.0.2",
  "@vueuse/motion": "^2.0.0-beta.27",
  codemirror: "^5.65.5",
  defu: "^6.1.2",
  drauu: "^0.3.2",
  "file-saver": "^2.0.5",
  "fuse.js": "^6.6.2",
  "js-base64": "^3.7.5",
  "js-yaml": "^4.1.0",
  katex: "^0.16.6",
  mermaid: "^10.1.0",
  "monaco-editor": "^0.37.1",
  nanoid: "^4.0.2",
  prettier: "^2.8.7",
  recordrtc: "^5.6.2",
  resolve: "^1.22.2",
  unocss: "^0.51.5",
  "vite-plugin-windicss": "^1.8.10",
  vue: "^3.2.47",
  "vue-router": "^4.1.6",
  "vue-starport": "^0.3.0",
  windicss: "^3.5.6"
};

// node/vite/searchRoot.ts


var ROOT_FILES = [
  // '.git',
  // https://pnpm.js.org/workspaces/
  "pnpm-workspace.yaml"
  // https://rushjs.io/pages/advanced/config_files/
  // 'rush.json',
  // https://nx.dev/latest/react/getting-started/nx-setup
  // 'workspace.json',
  // 'nx.json'
];
function hasWorkspacePackageJSON(root) {
  const path = _path.join.call(void 0, root, "package.json");
  try {
    _fs2.default.accessSync(path, _fs2.default.constants.R_OK);
  } catch (e2) {
    return false;
  }
  const content = JSON.parse(_fs2.default.readFileSync(path, "utf-8")) || {};
  return !!content.workspaces;
}
function hasRootFile(root) {
  return ROOT_FILES.some((file) => _fs2.default.existsSync(_path.join.call(void 0, root, file)));
}
function hasPackageJSON(root) {
  const path = _path.join.call(void 0, root, "package.json");
  return _fs2.default.existsSync(path);
}
function searchForPackageRoot(current, root = current) {
  if (hasPackageJSON(current))
    return current;
  const dir = _path.dirname.call(void 0, current);
  if (!dir || dir === current)
    return root;
  return searchForPackageRoot(dir, root);
}
function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
  if (hasRootFile(current))
    return current;
  if (hasWorkspacePackageJSON(current))
    return current;
  const dir = _path.dirname.call(void 0, current);
  if (!dir || dir === current)
    return root;
  return searchForWorkspaceRoot(dir, root);
}

// node/plugins/extendConfig.ts
var EXCLUDE = [
  "@slidev/shared",
  "@slidev/types",
  "@slidev/client",
  "@slidev/client/constants",
  "@slidev/client/logic/dark",
  "@vueuse/core",
  "@vueuse/shared",
  "@unocss/reset",
  "unocss",
  "mermaid",
  "vite-plugin-windicss",
  "vue-demi",
  "vue"
];
function createConfigPlugin(options) {
  return {
    name: "slidev:config",
    async config(config) {
      const injection = {
        define: getDefine(options),
        resolve: {
          alias: {
            "@slidev/client/": `${_chunkGE7W2DBEjs.toAtFS.call(void 0, options.clientRoot)}/`
          },
          dedupe: ["vue"]
        },
        optimizeDeps: {
          include: [
            ...Object.keys(dependencies).filter((i) => !EXCLUDE.includes(i)),
            "codemirror/mode/javascript/javascript",
            "codemirror/mode/css/css",
            "codemirror/mode/markdown/markdown",
            "codemirror/mode/xml/xml",
            "codemirror/mode/htmlmixed/htmlmixed",
            "codemirror/addon/display/placeholder",
            "prettier/esm/parser-babel",
            "prettier/esm/parser-html",
            "prettier/esm/parser-typescript",
            "mermaid/dist/mermaid.esm.min.mjs",
            "mermaid/dist/mermaid.esm.mjs",
            "vite-plugin-vue-server-ref/client"
          ],
          exclude: EXCLUDE
        },
        css: options.data.config.css === "unocss" ? {
          postcss: {
            plugins: [
              await Promise.resolve().then(() => require("postcss-nested")).then((r) => (r.default || r)())
            ]
          }
        } : {},
        server: {
          fs: {
            strict: true,
            allow: _utils.uniq.call(void 0, [
              searchForWorkspaceRoot(options.userRoot),
              searchForWorkspaceRoot(options.cliRoot),
              ..._isinstalledglobally2.default ? [_path.dirname.call(void 0, _chunkGE7W2DBEjs.resolveGlobalImportPath.call(void 0, "@slidev/client/package.json")), _path.dirname.call(void 0, _chunkGE7W2DBEjs.resolveGlobalImportPath.call(void 0, "katex/package.json"))] : []
            ])
          }
        },
        publicDir: _path.join.call(void 0, options.userRoot, "public")
      };
      if (_isinstalledglobally2.default) {
        injection.cacheDir = _path.join.call(void 0, options.cliRoot, "node_modules/.vite");
        injection.root = options.cliRoot;
        injection.resolve.alias.vue = `${_chunkGE7W2DBEjs.resolveImportPath.call(void 0, "vue/dist/vue.esm-browser.js", true)}`;
      }
      return _vite.mergeConfig.call(void 0, injection, config);
    },
    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          if (req.url.endsWith(".html")) {
            res.setHeader("Content-Type", "text/html");
            res.statusCode = 200;
            res.end(await getIndexHtml(options));
            return;
          }
          next();
        });
      };
    }
  };
}
function getDefine(options) {
  return {
    __DEV__: options.mode === "dev" ? "true" : "false",
    __SLIDEV_CLIENT_ROOT__: JSON.stringify(_chunkGE7W2DBEjs.toAtFS.call(void 0, options.clientRoot)),
    __SLIDEV_HASH_ROUTE__: JSON.stringify(options.data.config.routerMode === "hash"),
    __SLIDEV_FEATURE_DRAWINGS__: JSON.stringify(options.data.config.drawings.enabled === true || options.data.config.drawings.enabled === options.mode),
    __SLIDEV_FEATURE_DRAWINGS_PERSIST__: JSON.stringify(!!options.data.config.drawings.persist === true),
    __SLIDEV_FEATURE_RECORD__: JSON.stringify(options.data.config.record === true || options.data.config.record === options.mode),
    __SLIDEV_FEATURE_PRESENTER__: JSON.stringify(options.data.config.presenter === true || options.data.config.presenter === options.mode),
    __SLIDEV_HAS_SERVER__: options.mode !== "build" ? "true" : "false"
  };
}

// node/plugins/loaders.ts
var import_fast_deep_equal = _chunkGE7W2DBEjs.__toESM.call(void 0, require_fast_deep_equal());




var _markdownit = require('markdown-it'); var _markdownit2 = _interopRequireDefault(_markdownit);
var _markdownitlinkattributes = require('markdown-it-link-attributes'); var _markdownitlinkattributes2 = _interopRequireDefault(_markdownitlinkattributes);
var _fs3 = require('@slidev/parser/fs'); var parser = _interopRequireWildcard(_fs3);
var regexId = /^\/\@slidev\/slide\/(\d+)\.(md|json)(?:\?import)?$/;
var regexIdQuery = /(\d+?)\.(md|json)$/;
function getBodyJson(req) {
  return new Promise((resolve6, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve6(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
var md = _markdownit2.default.call(void 0, { html: true });
md.use(_markdownitlinkattributes2.default, {
  attrs: {
    target: "_blank",
    rel: "noopener"
  }
});
function prepareSlideInfo(data) {
  return {
    ...data,
    noteHTML: md.render((data == null ? void 0 : data.note) || "")
  };
}
function createSlidesLoader({ data, entry, clientRoot, themeRoots, addonRoots, userRoot, roots, remote }, pluginOptions, serverOptions, VuePlugin, MarkdownPlugin) {
  const slidePrefix = "/@slidev/slides/";
  const hmrPages = /* @__PURE__ */ new Set();
  let server;
  let _layouts_cache_time = 0;
  let _layouts_cache = {};
  return [
    {
      name: "slidev:loader",
      configureServer(_server) {
        server = _server;
        updateServerWatcher();
        server.middlewares.use(async (req, res, next) => {
          var _a;
          const match = (_a = req.url) == null ? void 0 : _a.match(regexId);
          if (!match)
            return next();
          const [, no, type] = match;
          const idx = parseInt(no);
          if (type === "json" && req.method === "GET") {
            res.write(JSON.stringify(prepareSlideInfo(data.slides[idx])));
            return res.end();
          }
          if (type === "json" && req.method === "POST") {
            const body = await getBodyJson(req);
            const slide = data.slides[idx];
            hmrPages.add(idx);
            if (slide.source) {
              Object.assign(slide.source, body);
              await parser.saveExternalSlide(slide.source);
            } else {
              Object.assign(slide, body);
              await parser.save(data, entry);
            }
            res.statusCode = 200;
            res.write(JSON.stringify(prepareSlideInfo(slide)));
            return res.end();
          }
          next();
        });
      },
      async handleHotUpdate(ctx) {
        var _a, _b, _c;
        if (!data.entries.some((i) => _utils.slash.call(void 0, i) === ctx.file))
          return;
        await ctx.read();
        const newData = await parser.load(entry, data.themeMeta);
        const moduleIds = /* @__PURE__ */ new Set();
        if (data.slides.length !== newData.slides.length) {
          moduleIds.add("/@slidev/routes");
          _utils.range.call(void 0, newData.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.headmatter.defaults, newData.headmatter.defaults)) {
          moduleIds.add("/@slidev/routes");
          _utils.range.call(void 0, data.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.config, newData.config))
          moduleIds.add("/@slidev/configs");
        if (!(0, import_fast_deep_equal.default)(data.features, newData.features)) {
          setTimeout(() => {
            ctx.server.ws.send({ type: "full-reload" });
          }, 1);
        }
        const length = Math.max(data.slides.length, newData.slides.length);
        for (let i = 0; i < length; i++) {
          const a = data.slides[i];
          const b = newData.slides[i];
          if ((a == null ? void 0 : a.content.trim()) === (b == null ? void 0 : b.content.trim()) && ((_a = a == null ? void 0 : a.title) == null ? void 0 : _a.trim()) === ((_b = b == null ? void 0 : b.title) == null ? void 0 : _b.trim()) && (a == null ? void 0 : a.note) === (b == null ? void 0 : b.note) && (0, import_fast_deep_equal.default)(a.frontmatter, b.frontmatter))
            continue;
          ctx.server.ws.send({
            type: "custom",
            event: "slidev-update",
            data: {
              id: i,
              data: prepareSlideInfo(newData.slides[i])
            }
          });
          hmrPages.add(i);
        }
        (_c = serverOptions.onDataReload) == null ? void 0 : _c.call(serverOptions, newData, data);
        Object.assign(data, newData);
        if (hmrPages.size > 0)
          moduleIds.add("/@slidev/titles.md");
        const vueModules = (await Promise.all(
          Array.from(hmrPages).map(async (i) => {
            var _a2;
            const file = `${slidePrefix}${i + 1}.md`;
            try {
              const md2 = await transformMarkdown((await MarkdownPlugin.transform((_a2 = newData.slides[i]) == null ? void 0 : _a2.content, file)).code, i, newData);
              const handleHotUpdate = "handler" in VuePlugin.handleHotUpdate ? VuePlugin.handleHotUpdate.handler : VuePlugin.handleHotUpdate;
              return await handleHotUpdate({
                ...ctx,
                modules: Array.from(ctx.server.moduleGraph.getModulesByFile(file) || []),
                file,
                read() {
                  return md2;
                }
              });
            } catch (e3) {
            }
          })
        )).flatMap((i) => i || []);
        hmrPages.clear();
        const moduleEntries = [
          ...vueModules,
          ...Array.from(moduleIds).map((id) => ctx.server.moduleGraph.getModuleById(id))
        ].filter(_utils.notNullish).filter((i) => {
          var _a2;
          return !((_a2 = i.id) == null ? void 0 : _a2.startsWith("/@id/@vite-icons"));
        });
        updateServerWatcher();
        return moduleEntries;
      },
      resolveId(id) {
        if (id.startsWith(slidePrefix) || id.startsWith("/@slidev/"))
          return id;
        return null;
      },
      load(id) {
        var _a;
        if (id === "/@slidev/routes")
          return generateRoutes();
        if (id === "/@slidev/layouts")
          return generateLayouts();
        if (id === "/@slidev/styles")
          return generateUserStyles();
        if (id === "/@slidev/monaco-types")
          return generateMonacoTypes();
        if (id === "/@slidev/configs")
          return generateConfigs();
        if (id === "/@slidev/global-components/top")
          return generateGlobalComponents("top");
        if (id === "/@slidev/global-components/bottom")
          return generateGlobalComponents("bottom");
        if (id === "/@slidev/custom-nav-controls")
          return generateCustomNavControls();
        if (id === "/@slidev/titles.md") {
          return {
            code: data.slides.map(({ title }, i) => {
              return `<template ${i === 0 ? "v-if" : "v-else-if"}="+no === ${i + 1}">

${title}

</template>`;
            }).join(""),
            map: { mappings: "" }
          };
        }
        if (id.startsWith(slidePrefix)) {
          const remaning = id.slice(slidePrefix.length);
          const match = remaning.match(regexIdQuery);
          if (match) {
            const [, no, type] = match;
            const pageNo = parseInt(no) - 1;
            if (type === "md") {
              return {
                code: (_a = data.slides[pageNo]) == null ? void 0 : _a.content,
                map: { mappings: "" }
              };
            }
          }
          return {
            code: "",
            map: { mappings: "" }
          };
        }
      }
    },
    {
      name: "slidev:layout-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.startsWith(slidePrefix))
          return;
        const remaning = id.slice(slidePrefix.length);
        const match = remaning.match(regexIdQuery);
        if (!match)
          return;
        const [, no, type] = match;
        if (type !== "md")
          return;
        const pageNo = parseInt(no) - 1;
        return transformMarkdown(code, pageNo, data);
      }
    },
    {
      name: "slidev:context-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.endsWith(".vue"))
          return;
        return transformVue(code);
      }
    },
    {
      name: "slidev:title-transform:pre",
      enforce: "pre",
      transform(code, id) {
        if (id !== "/@slidev/titles.md")
          return;
        return transformTitles(code);
      }
    },
    {
      name: "slidev:slide-transform:post",
      enforce: "post",
      transform(code, id) {
        if (!id.match(/\/@slidev\/slides\/\d+\.md($|\?)/))
          return;
        return code.replace("if (_rerender_only)", "if (false)");
      }
    }
  ];
  function updateServerWatcher() {
    var _a;
    if (!server)
      return;
    server.watcher.add(((_a = data.entries) == null ? void 0 : _a.map(_utils.slash)) || []);
  }
  async function transformMarkdown(code, pageNo, data2) {
    var _a, _b;
    const layouts = await getLayouts();
    const frontmatter = {
      ...((_a = data2.headmatter) == null ? void 0 : _a.defaults) || {},
      ...((_b = data2.slides[pageNo]) == null ? void 0 : _b.frontmatter) || {}
    };
    const layoutName = (frontmatter == null ? void 0 : frontmatter.layout) || (pageNo === 0 ? "cover" : "default");
    if (!layouts[layoutName])
      throw new Error(`Unknown layout "${layoutName}"`);
    delete frontmatter.title;
    const imports = [
      'import { inject as vueInject } from "vue"',
      `import InjectedLayout from "${_chunkGE7W2DBEjs.toAtFS.call(void 0, layouts[layoutName])}"`,
      'import { injectionSlidevContext } from "@slidev/client/constants.ts"',
      `const frontmatter = ${JSON.stringify(frontmatter)}`,
      "const $slidev = vueInject(injectionSlidevContext)"
    ];
    code = code.replace(/(<script setup.*>)/g, `$1
${imports.join("\n")}
`);
    const injectA = code.indexOf("<template>") + "<template>".length;
    const injectB = code.lastIndexOf("</template>");
    let body = code.slice(injectA, injectB).trim();
    if (body.startsWith("<div>") && body.endsWith("</div>"))
      body = body.slice(5, -6);
    code = `${code.slice(0, injectA)}
<InjectedLayout v-bind="frontmatter">
${body}
</InjectedLayout>
${code.slice(injectB)}`;
    return code;
  }
  function transformVue(code) {
    if (code.includes("injectionSlidevContext"))
      return code;
    const imports = [
      'import { inject as vueInject } from "vue"',
      'import { injectionSlidevContext } from "@slidev/client/constants.ts"',
      "const $slidev = vueInject(injectionSlidevContext)"
    ];
    const matchScript = code.match(/<script((?!setup).)*(setup)?.*>/);
    if (matchScript && matchScript[2]) {
      return code.replace(/(<script.*>)/g, `$1
${imports.join("\n")}
`);
    } else if (matchScript && !matchScript[2]) {
      const matchExport = code.match(/export\s+default\s+{/);
      if (matchExport) {
        const exportIndex = (matchExport.index || 0) + matchExport[0].length;
        let component = code.slice(exportIndex);
        component = component.slice(0, component.indexOf("</script>"));
        const scriptIndex = (matchScript.index || 0) + matchScript[0].length;
        const provideImport = '\nimport { injectionSlidevContext } from "@slidev/client/constants.ts"\n';
        code = `${code.slice(0, scriptIndex)}${provideImport}${code.slice(scriptIndex)}`;
        let injectIndex = exportIndex + provideImport.length;
        let injectObject = "$slidev: { from: injectionSlidevContext },";
        const matchInject = component.match(/.*inject\s*:\s*([\[{])/);
        if (matchInject) {
          injectIndex += (matchInject.index || 0) + matchInject[0].length;
          if (matchInject[1] === "[") {
            let injects = component.slice((matchInject.index || 0) + matchInject[0].length);
            const injectEndIndex = injects.indexOf("]");
            injects = injects.slice(0, injectEndIndex);
            injectObject += injects.split(",").map((inject) => `${inject}: {from: ${inject}}`).join(",");
            return `${code.slice(0, injectIndex - 1)}{
${injectObject}
}${code.slice(injectIndex + injectEndIndex + 1)}`;
          } else {
            return `${code.slice(0, injectIndex)}
${injectObject}
${code.slice(injectIndex)}`;
          }
        }
        return `${code.slice(0, injectIndex)}
inject: { ${injectObject} },
${code.slice(injectIndex)}`;
      }
    }
    return `<script setup>
${imports.join("\n")}
</script>
${code}`;
  }
  function transformTitles(code) {
    return code.replace(/<template>\s*<div>\s*<p>/, "<template>").replace(/<\/p>\s*<\/div>\s*<\/template>/, "</template>").replace(/<script\ssetup>/, `<script setup lang="ts">
defineProps<{ no: number | string }>()`);
  }
  async function getLayouts() {
    const now = Date.now();
    if (now - _layouts_cache_time < 2e3)
      return _layouts_cache;
    const layouts = {};
    const roots2 = _utils.uniq.call(void 0, [
      userRoot,
      ...themeRoots,
      ...addonRoots,
      clientRoot
    ]);
    for (const root of roots2) {
      const layoutPaths = await _fastglob2.default.call(void 0, "layouts/**/*.{vue,ts}", {
        cwd: root,
        absolute: true,
        suppressErrors: true
      });
      for (const layoutPath of layoutPaths) {
        const layout = _path.basename.call(void 0, layoutPath).replace(/\.\w+$/, "");
        if (layouts[layout])
          continue;
        layouts[layout] = layoutPath;
      }
    }
    _layouts_cache_time = now;
    _layouts_cache = layouts;
    return layouts;
  }
  async function generateUserStyles() {
    const imports = [
      `import "${_chunkGE7W2DBEjs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/vars.css"))}"`,
      `import "${_chunkGE7W2DBEjs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/index.css"))}"`,
      `import "${_chunkGE7W2DBEjs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/code.css"))}"`,
      `import "${_chunkGE7W2DBEjs.toAtFS.call(void 0, _path.join.call(void 0, clientRoot, "styles/transitions.css"))}"`
    ];
    const roots2 = _utils.uniq.call(void 0, [
      ...themeRoots,
      ...addonRoots,
      userRoot
    ]);
    for (const root of roots2) {
      const styles = [
        _path.join.call(void 0, root, "styles", "index.ts"),
        _path.join.call(void 0, root, "styles", "index.js"),
        _path.join.call(void 0, root, "styles", "index.css"),
        _path.join.call(void 0, root, "styles.css"),
        _path.join.call(void 0, root, "style.css")
      ];
      for (const style of styles) {
        if (_fsextra.existsSync.call(void 0, style)) {
          imports.push(`import "${_chunkGE7W2DBEjs.toAtFS.call(void 0, style)}"`);
          continue;
        }
      }
    }
    if (data.features.katex)
      imports.push(`import "${_chunkGE7W2DBEjs.toAtFS.call(void 0, _chunkGE7W2DBEjs.resolveImportPath.call(void 0, "katex/dist/katex.min.css", true))}"`);
    if (data.config.css === "unocss") {
      imports.unshift(
        'import "@unocss/reset/tailwind.css"',
        'import "uno:preflights.css"',
        'import "uno:typography.css"',
        'import "uno:shortcuts.css"'
      );
      imports.push('import "uno.css"');
    } else {
      imports.unshift(
        'import "virtual:windi-components.css"',
        'import "virtual:windi-base.css"'
      );
      imports.push('import "virtual:windi-utilities.css"');
      if (process.env.NODE_ENV !== "production")
        imports.push('import "virtual:windi-devtools"');
    }
    return imports.join("\n");
  }
  async function generateMonacoTypes() {
    return `void 0; ${parser.scanMonacoModules(data.raw).map((i) => `import('/@slidev-monaco-types/${i}')`).join("\n")}`;
  }
  async function generateLayouts() {
    const imports = [];
    const layouts = _utils.objectMap.call(void 0, 
      await getLayouts(),
      (k, v) => {
        imports.push(`import __layout_${k} from "${_chunkGE7W2DBEjs.toAtFS.call(void 0, v)}"`);
        return [k, `__layout_${k}`];
      }
    );
    return [
      imports.join("\n"),
      `export default {
${Object.entries(layouts).map(([k, v]) => `"${k}": ${v}`).join(",\n")}
}`
    ].join("\n\n");
  }
  async function generateRoutes() {
    const imports = [];
    const layouts = await getLayouts();
    imports.push(`import __layout__end from '${layouts.end}'`);
    let no = 1;
    const routes = [
      ...data.slides.map((i, idx) => {
        var _a, _b, _c, _d;
        if ((_a = i.frontmatter) == null ? void 0 : _a.disabled)
          return void 0;
        imports.push(`import n${no} from '${slidePrefix}${idx + 1}.md'`);
        const additions = {
          slide: {
            ...prepareSlideInfo(i),
            filepath: ((_b = i.source) == null ? void 0 : _b.filepath) || entry,
            id: idx,
            no
          },
          __clicksElements: [],
          __preloaded: false
        };
        const meta = Object.assign({}, i.frontmatter, additions);
        const route = `{ path: '${no}', name: 'page-${no}', component: n${no}, meta: ${JSON.stringify(meta)} }`;
        const redirect = ((_c = i.frontmatter) == null ? void 0 : _c.routeAlias) ? `{ path: '${(_d = i.frontmatter) == null ? void 0 : _d.routeAlias}', redirect: { path: '${no}' } }` : null;
        no += 1;
        return [route, redirect];
      }).flat().filter(_utils.notNullish),
      `{ path: "${no}", component: __layout__end, meta: { layout: "end" } }`
    ];
    const routesStr = `export default [
${routes.join(",\n")}
]`;
    return [...imports, routesStr].join("\n");
  }
  function generateConfigs() {
    const config = { ...data.config, remote };
    if (_utils.isString.call(void 0, config.title)) {
      const tokens = md.parseInline(config.title, {});
      config.title = _chunkGE7W2DBEjs.stringifyMarkdownTokens.call(void 0, tokens);
    }
    if (_utils.isString.call(void 0, config.info))
      config.info = md.render(config.info);
    return `export default ${JSON.stringify(config)}`;
  }
  async function generateGlobalComponents(layer) {
    const components = roots.flatMap((root) => {
      if (layer === "top") {
        return [
          _path.join.call(void 0, root, "global.vue"),
          _path.join.call(void 0, root, "global-top.vue"),
          _path.join.call(void 0, root, "GlobalTop.vue")
        ];
      } else {
        return [
          _path.join.call(void 0, root, "global-bottom.vue"),
          _path.join.call(void 0, root, "GlobalBottom.vue")
        ];
      }
    }).filter((i) => _fsextra2.default.existsSync(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${_chunkGE7W2DBEjs.toAtFS.call(void 0, i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
  render() {
    return [${render}]
  }
}
`;
  }
  async function generateCustomNavControls() {
    const components = roots.flatMap((root) => {
      return [
        _path.join.call(void 0, root, "custom-nav-controls.vue"),
        _path.join.call(void 0, root, "CustomNavControls.vue")
      ];
    }).filter((i) => _fsextra2.default.existsSync(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${_chunkGE7W2DBEjs.toAtFS.call(void 0, i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
  render() {
    return [${render}]
  }
}
`;
  }
}

// node/plugins/monacoTransform.ts


async function getPackageData(pkg) {
  const { resolvePackageData } = await Promise.resolve().then(() => require("vite"));
  const info = resolvePackageData(pkg, process.cwd());
  if (!info)
    return;
  const typePath = info.data.types || info.data.typings;
  if (!typePath)
    return;
  return [info, typePath];
}
function createMonacoTypesLoader() {
  return {
    name: "slidev:monaco-types-loader",
    resolveId(id) {
      if (id.startsWith("/@slidev-monaco-types/"))
        return id;
      return null;
    },
    async load(id) {
      const match = id.match(/^\/\@slidev-monaco-types\/(.*)$/);
      if (match) {
        const pkg = match[1];
        const packageData = await getPackageData(pkg) || await getPackageData(`@types/${pkg}`);
        if (!packageData)
          return;
        const [info, typePath] = packageData;
        return [
          "import * as monaco from 'monaco-editor'",
          `import Type from "${_utils.slash.call(void 0, _path.join.call(void 0, info.dir, typePath))}?raw"`,
          ...Object.keys(info.data.dependencies || {}).map((i) => `import "/@slidev-monaco-types/${i}"`),
          `monaco.languages.typescript.typescriptDefaults.addExtraLib(\`declare module "${pkg}" { \${Type} }\`)`
        ].join("\n");
      }
    }
  };
}

// node/plugins/setupClient.ts



function createClientSetupPlugin({ clientRoot, themeRoots, addonRoots, userRoot }) {
  const setupEntry = _utils.slash.call(void 0, _path.resolve.call(void 0, clientRoot, "setup"));
  return {
    name: "slidev:setup",
    enforce: "pre",
    async transform(code, id) {
      if (id.startsWith(setupEntry)) {
        let getInjections2 = function(isAwait = false, isChained = false) {
          return injections.join("\n").replace(/:AWAIT:/g, isAwait ? "await " : "").replace(/(,\s*)?:LAST:/g, isChained ? "$1injection_return" : "");
        };
        var getInjections = getInjections2;
        const name = id.slice(setupEntry.length + 1).replace(/\?.*$/, "");
        const imports = [];
        const injections = [];
        const setups = _utils.uniq.call(void 0, [
          ...themeRoots,
          ...addonRoots,
          userRoot
        ]).map((i) => _path.join.call(void 0, i, "setup", name));
        setups.forEach((path, idx) => {
          if (!_fs.existsSync.call(void 0, path))
            return;
          imports.push(`import __n${idx} from '${_chunkGE7W2DBEjs.toAtFS.call(void 0, path)}'`);
          let fn = `:AWAIT:__n${idx}`;
          if (/\binjection_return\b/g.test(code))
            fn = `injection_return = ${fn}`;
          if (/\binjection_arg\b/g.test(code)) {
            fn += "(";
            const matches = Array.from(code.matchAll(/\binjection_arg(_\d+)?\b/g));
            const dedupedMatches = Array.from(new Set(matches.map((m) => m[0])));
            fn += dedupedMatches.join(", ");
            fn += ", :LAST:)";
          } else {
            fn += "(:LAST:)";
          }
          injections.push(
            `// ${path}`,
            fn
          );
        });
        code = code.replace("/* __imports__ */", imports.join("\n"));
        code = code.replace("/* __injections__ */", getInjections2());
        code = code.replace("/* __async_injections__ */", getInjections2(true));
        code = code.replace("/* __chained_injections__ */", getInjections2(false, true));
        code = code.replace("/* __chained_async_injections__ */", getInjections2(true, true));
        return code;
      }
      return null;
    }
  };
}

// node/plugins/markdown.ts
var _vitepluginvuemarkdown = require('vite-plugin-vue-markdown'); var _vitepluginvuemarkdown2 = _interopRequireDefault(_vitepluginvuemarkdown);
var _jsbase64 = require('js-base64'); var base64 = _interopRequireWildcard(_jsbase64);


var _markdownitfootnote = require('markdown-it-footnote'); var _markdownitfootnote2 = _interopRequireDefault(_markdownitfootnote);
var _markdownitplugins = require('@hedgedoc/markdown-it-plugins');
var _shiki = require('shiki'); var Shiki = _interopRequireWildcard(_shiki);
var _plantumlencoder = require('plantuml-encoder');

// node/plugins/markdown-it-katex.ts
var _katex = require('katex'); var _katex2 = _interopRequireDefault(_katex);
function isValidDelim(state, pos) {
  const max = state.posMax;
  let can_open = true;
  let can_close = true;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || /* \t */
  nextChar >= 48 && nextChar <= 57)
    can_close = false;
  if (nextChar === 32 || nextChar === 9)
    can_open = false;
  return {
    can_open,
    can_close
  };
}
function math_inline(state, silent) {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$")
    return false;
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent)
      state.pending += "$";
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\")
      pos -= 1;
    if ((match - pos) % 2 === 1)
      break;
    match += 1;
  }
  if (match === -1) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += "$$";
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
}
function math_block(state, start, end, silent) {
  let firstLine;
  let lastLine;
  let next;
  let lastPos;
  let found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  if (pos + 2 > max)
    return false;
  if (state.src.slice(pos, pos + 2) !== "$$")
    return false;
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent)
    return true;
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end)
      break;
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? `${firstLine}
` : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
}
function math_plugin(md2, options) {
  options = options || {};
  const katexInline = function(latex) {
    options.displayMode = false;
    try {
      return _katex2.default.renderToString(latex, options);
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const inlineRenderer = function(tokens, idx) {
    return katexInline(tokens[idx].content);
  };
  const katexBlock = function(latex) {
    options.displayMode = true;
    try {
      return `<p>${_katex2.default.renderToString(latex, options)}</p>`;
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const blockRenderer = function(tokens, idx) {
    return `${katexBlock(tokens[idx].content)}
`;
  };
  md2.inline.ruler.after("escape", "math_inline", math_inline);
  md2.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md2.renderer.rules.math_inline = inlineRenderer;
  md2.renderer.rules.math_block = blockRenderer;
}

// node/plugins/markdown-it-prism.ts
var _prismjs = require('prismjs'); var _prismjs2 = _interopRequireDefault(_prismjs);
var _ = require('prismjs/components/'); var _2 = _interopRequireDefault(_);
var DEFAULTS = {
  plugins: [],
  init: () => {
  },
  defaultLanguageForUnknown: void 0,
  defaultLanguageForUnspecified: void 0,
  defaultLanguage: void 0
};
function loadPrismLang(lang) {
  if (!lang)
    return void 0;
  let langObject = _prismjs2.default.languages[lang];
  if (langObject === void 0) {
    _2.default.call(void 0, [lang]);
    langObject = _prismjs2.default.languages[lang];
  }
  return langObject;
}
function loadPrismPlugin(name) {
  try {
    _chunkGE7W2DBEjs.__require.call(void 0, `prismjs/plugins/${name}/prism-${name}`);
  } catch (e) {
    throw new Error(`Cannot load Prism plugin "${name}". Please check the spelling.`);
  }
}
function selectLanguage(options, lang) {
  let langToUse = lang;
  if (langToUse === "" && options.defaultLanguageForUnspecified !== void 0)
    langToUse = options.defaultLanguageForUnspecified;
  let prismLang = loadPrismLang(langToUse);
  if (prismLang === void 0 && options.defaultLanguageForUnknown !== void 0) {
    langToUse = options.defaultLanguageForUnknown;
    prismLang = loadPrismLang(langToUse);
  }
  return [langToUse, prismLang];
}
function highlight(markdownit, options, text, lang) {
  const [langToUse, prismLang] = selectLanguage(options, lang);
  const code = text.trimEnd().split(/\r?\n/g).map((line) => prismLang ? _prismjs2.default.highlight(line, prismLang, langToUse) : markdownit.utils.escapeHtml(line)).map((line) => `<span class="line">${line}</span>`).join("\n");
  const classAttribute = langToUse ? ` class="slidev-code ${markdownit.options.langPrefix}${markdownit.utils.escapeHtml(langToUse)}"` : "";
  return escapeVueInCode(`<pre${classAttribute}><code>${code}</code></pre>`);
}
function checkLanguageOption(options, optionName) {
  const language = options[optionName];
  if (language !== void 0 && loadPrismLang(language) === void 0)
    throw new Error(`Bad option ${optionName}: There is no Prism language '${language}'.`);
}
function markdownItPrism(markdownit, useroptions) {
  const options = Object.assign({}, DEFAULTS, useroptions);
  checkLanguageOption(options, "defaultLanguage");
  checkLanguageOption(options, "defaultLanguageForUnknown");
  checkLanguageOption(options, "defaultLanguageForUnspecified");
  options.defaultLanguageForUnknown = options.defaultLanguageForUnknown || options.defaultLanguage;
  options.defaultLanguageForUnspecified = options.defaultLanguageForUnspecified || options.defaultLanguage;
  options.plugins.forEach(loadPrismPlugin);
  options.init(_prismjs2.default);
  markdownit.options.highlight = (text, lang) => highlight(markdownit, options, text, lang);
}

// node/plugins/markdown-it-shiki.ts
function getThemeName(theme) {
  if (typeof theme === "string")
    return theme;
  return theme.name;
}
function isShikiDarkModeThemes(theme) {
  return typeof theme === "object" && ("dark" in theme || "light" in theme);
}
function resolveShikiOptions(options) {
  const themes = [];
  let darkModeThemes;
  if (!options.theme) {
    themes.push("nord");
  } else if (typeof options.theme === "string") {
    themes.push(options.theme);
  } else {
    if (isShikiDarkModeThemes(options.theme)) {
      darkModeThemes = options.theme;
      themes.push(options.theme.dark);
      themes.push(options.theme.light);
    } else {
      themes.push(options.theme);
    }
  }
  return {
    ...options,
    themes,
    darkModeThemes: darkModeThemes ? {
      dark: getThemeName(darkModeThemes.dark),
      light: getThemeName(darkModeThemes.light)
    } : void 0
  };
}
function trimEndNewLine(code) {
  return code.replace(/\n$/, "");
}
var MarkdownItShiki = (markdownit, options = {}) => {
  const _highlighter = options.highlighter;
  const { darkModeThemes } = resolveShikiOptions(options);
  markdownit.options.highlight = (code, lang) => {
    if (darkModeThemes) {
      const trimmed = trimEndNewLine(code);
      const dark = _highlighter.codeToHtml(trimmed, { lang: lang || "text", theme: darkModeThemes.dark }).replace('<pre class="shiki', '<pre class="slidev-code shiki shiki-dark');
      const light = _highlighter.codeToHtml(trimmed, { lang: lang || "text", theme: darkModeThemes.light }).replace('<pre class="shiki', '<pre class="slidev-code shiki shiki-light');
      return escapeVueInCode(`<pre class="shiki-container">${dark}${light}</pre>`);
    } else {
      return escapeVueInCode(
        _highlighter.codeToHtml(code, { lang: lang || "text" }).replace('<pre class="shiki"', '<pre class="slidev-code shiki"')
      );
    }
  };
};
var markdown_it_shiki_default = MarkdownItShiki;

// node/plugins/markdown.ts
var DEFAULT_SHIKI_OPTIONS = {
  theme: {
    dark: "min-dark",
    light: "min-light"
  }
};
async function createMarkdownPlugin({ data: { config }, roots, mode, entry }, { markdown: mdOptions }) {
  const setups = [];
  const entryPath = _utils.slash.call(void 0, entry);
  if (config.highlighter === "shiki") {
    const { getHighlighter } = await Promise.resolve().then(() => require("shiki"));
    const shikiOptions = await loadSetups(roots, "shiki.ts", Shiki, DEFAULT_SHIKI_OPTIONS, false);
    const { langs, themes } = resolveShikiOptions(shikiOptions);
    shikiOptions.highlighter = await getHighlighter({ themes, langs });
    setups.push((md2) => md2.use(markdown_it_shiki_default, shikiOptions));
  } else {
    setups.push((md2) => md2.use(markdownItPrism));
  }
  const KatexOptions = await loadSetups(roots, "katex.ts", {}, { strict: false }, false);
  return _vitepluginvuemarkdown2.default.call(void 0, {
    wrapperClasses: "",
    headEnabled: false,
    frontmatter: false,
    markdownItOptions: {
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true,
      ...mdOptions == null ? void 0 : mdOptions.markdownItOptions
    },
    ...mdOptions,
    markdownItSetup(md2) {
      var _a;
      md2.use(_markdownitlinkattributes2.default, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
      md2.use(_markdownitfootnote2.default);
      md2.use(_markdownitplugins.taskLists, { enabled: true, lineNumber: true, label: true });
      md2.use(math_plugin, KatexOptions);
      setups.forEach((i) => i(md2));
      (_a = mdOptions == null ? void 0 : mdOptions.markdownItSetup) == null ? void 0 : _a.call(mdOptions, md2);
    },
    transforms: {
      before(code, id) {
        if (id === entryPath)
          return "";
        const monaco = config.monaco === true || config.monaco === mode ? transformMarkdownMonaco : truncateMancoMark;
        code = transformSlotSugar(code);
        code = transformMermaid(code);
        code = transformPlantUml(code, config.plantUmlServer);
        code = monaco(code);
        code = transformHighlighter(code);
        code = transformPageCSS(code, id);
        return code;
      }
    }
  });
}
function transformMarkdownMonaco(md2) {
  md2 = md2.replace(/^```(\w+?)\s*{monaco-diff}\s*?({.*?})?\s*?\n([\s\S]+?)^~~~\s*?\n([\s\S]+?)^```/mg, (full, lang = "ts", options = "{}", code, diff) => {
    lang = lang.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    const encodedDiff = base64.encode(diff, true);
    return `<Monaco :code="'${encoded}'" :diff="'${encodedDiff}'" lang="${lang}" v-bind="${options}" />`;
  });
  md2 = md2.replace(/^```(\w+?)\s*{monaco}\s*?({.*?})?\s*?\n([\s\S]+?)^```/mg, (full, lang = "ts", options = "{}", code) => {
    lang = lang.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Monaco :code="'${encoded}'" lang="${lang}" v-bind="${options}" />`;
  });
  return md2;
}
function truncateMancoMark(md2) {
  return md2.replace(/{monaco.*?}/g, "");
}
function transformSlotSugar(md2) {
  const lines = md2.split(/\r?\n/g);
  let prevSlot = false;
  const { isLineInsideCodeblocks } = getCodeBlocks(md2);
  lines.forEach((line, idx) => {
    if (isLineInsideCodeblocks(idx))
      return;
    const match = line.trimEnd().match(/^::\s*(\w+)\s*::$/);
    if (match) {
      lines[idx] = `${prevSlot ? "\n\n</template>\n" : "\n"}<template v-slot:${match[1]}="slotProps">
`;
      prevSlot = true;
    }
  });
  if (prevSlot)
    lines[lines.length - 1] += "\n\n</template>";
  return lines.join("\n");
}
function transformHighlighter(md2) {
  return md2.replace(/^```(\w+?)(?:\s*{([\d\w*,\|-]+)}\s*?({.*?})?\s*?)?\n([\s\S]+?)^```/mg, (full, lang = "", rangeStr = "", options = "", code) => {
    const ranges = rangeStr.split(/\|/g).map((i) => i.trim());
    code = code.trimEnd();
    options = options.trim() || "{}";
    return `
<CodeBlockWrapper v-bind="${options}" :ranges='${JSON.stringify(ranges)}'>

\`\`\`${lang}
${code}
\`\`\`

</CodeBlockWrapper>`;
  });
}
function getCodeBlocks(md2) {
  const codeblocks = Array.from(md2.matchAll(/^```[\s\S]*?^```/mg)).map((m) => {
    var _a, _b;
    const start = m.index;
    const end = m.index + m[0].length;
    const startLine = ((_a = md2.slice(0, start).match(/\n/g)) == null ? void 0 : _a.length) || 0;
    const endLine = ((_b = md2.slice(0, end).match(/\n/g)) == null ? void 0 : _b.length) || 0;
    return [start, end, startLine, endLine];
  });
  return {
    codeblocks,
    isInsideCodeblocks(idx) {
      return codeblocks.some(([s, e]) => s <= idx && idx <= e);
    },
    isLineInsideCodeblocks(line) {
      return codeblocks.some(([, , s, e]) => s <= line && line <= e);
    }
  };
}
function transformPageCSS(md2, id) {
  var _a;
  const page = (_a = id.match(/(\d+)\.md$/)) == null ? void 0 : _a[1];
  if (!page)
    return md2;
  const { isInsideCodeblocks } = getCodeBlocks(md2);
  const result = md2.replace(
    /(\n<style[^>]*?>)([\s\S]+?)(<\/style>)/g,
    (full, start, css, end, index) => {
      if (index < 0 || isInsideCodeblocks(index))
        return full;
      if (!start.includes("scoped"))
        start = start.replace("<style", "<style scoped");
      return `${start}
${css}${end}`;
    }
  );
  return result;
}
function transformMermaid(md2) {
  return md2.replace(/^```mermaid\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", code = "") => {
    code = code.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Mermaid :code="'${encoded}'" v-bind="${options}" />`;
  });
}
function transformPlantUml(md2, server) {
  return md2.replace(/^```plantuml\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", content = "") => {
    const code = _plantumlencoder.encode.call(void 0, content.trim());
    options = options.trim() || "{}";
    return `<PlantUml :code="'${code}'" :server="'${server}'" v-bind="${options}" />`;
  });
}
function escapeVueInCode(md2) {
  return md2.replace(/{{(.*?)}}/g, "&lbrace;&lbrace;$1&rbrace;&rbrace;");
}

// node/plugins/patchTransform.ts

function createFixPlugins(options) {
  const define = _utils.objectEntries.call(void 0, getDefine(options));
  return [
    {
      name: "slidev:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.match(/\.vue($|\?)/)) {
          const original = code;
          define.forEach(([from, to]) => {
            code = code.replace(new RegExp(from, "g"), to);
          });
          if (original !== code)
            return code;
        }
      }
    }
  ];
}

// node/plugins/unocss.ts




async function createUnocssPlugin({ themeRoots, addonRoots, clientRoot, roots, userRoot, data }, { unocss: unoOptions }) {
  var _a, _b, _c, _d;
  const UnoCSS = await Promise.resolve().then(() => require("unocss/vite")).then((r) => r.default);
  const configFiles = _utils.uniq.call(void 0, [
    _path.resolve.call(void 0, userRoot, "uno.config.ts"),
    _path.resolve.call(void 0, userRoot, "unocss.config.ts"),
    ...themeRoots.map((i) => `${i}/uno.config.ts`),
    ...themeRoots.map((i) => `${i}/unocss.config.ts`),
    ...addonRoots.map((i) => `${i}/uno.config.ts`),
    ...addonRoots.map((i) => `${i}/unocss.config.ts`),
    _path.resolve.call(void 0, clientRoot, "uno.config.ts"),
    _path.resolve.call(void 0, clientRoot, "unocss.config.ts")
  ]);
  const configFile = configFiles.find((i) => _fs.existsSync.call(void 0, i));
  let config = _jiti2.default.call(void 0, __filename)(configFile);
  if ("default" in config)
    config = config.default;
  config = await loadSetups(roots, "unocss.ts", {}, config, true);
  config.theme || (config.theme = {});
  (_a = config.theme).fontFamily || (_a.fontFamily = {});
  (_b = config.theme.fontFamily).sans || (_b.sans = data.config.fonts.sans.join(","));
  (_c = config.theme.fontFamily).mono || (_c.mono = data.config.fonts.mono.join(","));
  (_d = config.theme.fontFamily).serif || (_d.serif = data.config.fonts.serif.join(","));
  return UnoCSS({
    configFile: false,
    ..._utils.deepMerge.call(void 0, config, unoOptions || {})
  });
}

// node/plugins/preset.ts
var customElements = /* @__PURE__ */ new Set([
  // katex
  "annotation",
  "math",
  "menclose",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
]);
async function ViteSlidevPlugin(options, pluginOptions, serverOptions = {}) {
  const {
    vue: vueOptions = {},
    vuejsx: vuejsxOptions = {},
    components: componentsOptions = {},
    icons: iconsOptions = {},
    remoteAssets: remoteAssetsOptions = {},
    serverRef: serverRefOptions = {}
  } = pluginOptions;
  const {
    mode,
    themeRoots,
    addonRoots,
    clientRoot,
    data: { config }
  } = options;
  const VuePlugin = _pluginvue2.default.call(void 0, {
    include: [/\.vue$/, /\.md$/],
    exclude: [],
    template: {
      compilerOptions: {
        isCustomElement(tag) {
          return customElements.has(tag);
        }
      },
      ...vueOptions == null ? void 0 : vueOptions.template
    },
    ...vueOptions
  });
  const VueJsxPlugin = _pluginvuejsx2.default.call(void 0, vuejsxOptions);
  const MarkdownPlugin = await createMarkdownPlugin(options, pluginOptions);
  const drawingData = await loadDrawings(options);
  const publicRoots = themeRoots.map((i) => _path.join.call(void 0, i, "public")).filter(_fs.existsSync);
  return [
    MarkdownPlugin,
    VueJsxPlugin,
    VuePlugin,
    createSlidesLoader(options, pluginOptions, serverOptions, VuePlugin, MarkdownPlugin),
    _vite6.default.call(void 0, {
      extensions: ["vue", "md", "js", "ts", "jsx", "tsx"],
      dirs: [
        _path.join.call(void 0, clientRoot, "builtin"),
        _path.join.call(void 0, clientRoot, "components"),
        ...themeRoots.map((i) => _path.join.call(void 0, i, "components")),
        ...addonRoots.map((i) => _path.join.call(void 0, i, "components")),
        "src/components",
        "components"
      ],
      include: [/\.vue$/, /\.vue\?vue/, /\.vue\?v=/, /\.md$/],
      exclude: [],
      resolvers: [
        _resolver2.default.call(void 0, {
          prefix: "",
          customCollections: Object.keys(iconsOptions.customCollections || [])
        })
      ],
      dts: false,
      ...componentsOptions
    }),
    _vite4.default.call(void 0, {
      defaultClass: "slidev-icon",
      autoInstall: true,
      ...iconsOptions
    }),
    config.remoteAssets === true || config.remoteAssets === mode ? _vitepluginremoteassets2.default.call(void 0, {
      rules: [
        ..._vitepluginremoteassets.DefaultRules,
        {
          match: /\b(https?:\/\/image.unsplash\.com.*?)(?=[`'")\]])/ig,
          ext: ".png"
        }
      ],
      resolveMode: (id) => id.endsWith("index.html") ? "relative" : "@fs",
      awaitDownload: mode === "build",
      ...remoteAssetsOptions
    }) : null,
    _vitepluginvueserverref2.default.call(void 0, {
      debug: process.env.NODE_ENV === "development",
      state: {
        sync: false,
        nav: {
          page: 0,
          clicks: 0
        },
        drawings: drawingData,
        ...serverRefOptions.state
      },
      onChanged(key, data, patch, timestamp) {
        serverRefOptions.onChanged && serverRefOptions.onChanged(key, data, patch, timestamp);
        if (!options.data.config.drawings.persist)
          return;
        if (key === "drawings")
          writeDrawings(options, _nullishCoalesce(patch, () => ( data)));
      }
    }),
    publicRoots.length ? _vitepluginstaticcopy.viteStaticCopy.call(void 0, {
      silent: true,
      targets: publicRoots.map((r) => ({
        src: `${r}/*`,
        dest: "theme"
      }))
    }) : null,
    createConfigPlugin(options),
    createClientSetupPlugin(options),
    createMonacoTypesLoader(),
    createFixPlugins(options),
    options.inspect ? _viteplugininspect2.default.call(void 0, {
      dev: true,
      build: true
    }) : null,
    config.css === "none" ? null : config.css === "unocss" ? await createUnocssPlugin(options, pluginOptions) : await createWindiCSSPlugin(options, pluginOptions)
  ].flat().filter(_utils.notNullish);
}








exports.getIndexHtml = getIndexHtml; exports.mergeViteConfigs = mergeViteConfigs; exports.require_fast_deep_equal = require_fast_deep_equal; exports.loadSetups = loadSetups; exports.createWindiCSSPlugin = createWindiCSSPlugin; exports.ViteSlidevPlugin = ViteSlidevPlugin;
