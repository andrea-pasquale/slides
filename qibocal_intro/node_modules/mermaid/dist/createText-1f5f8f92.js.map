{"version":3,"file":"createText-1f5f8f92.js","sources":["../src/rendering-util/handle-markdown-text.js","../src/rendering-util/createText.js"],"sourcesContent":["import SimpleMarkdown from '@khanacademy/simple-markdown';\n\n/**\n *\n * @param markdown\n */\nfunction preprocessMarkdown(markdown) {\n  // Replace multiple newlines with a single newline\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, '\\n');\n  // Remove extra spaces at the beginning of each line\n  const withoutExtraSpaces = withoutMultipleNewlines.replace(/^\\s+/gm, '');\n  return withoutExtraSpaces;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(preprocessedMarkdown);\n\n  let lines = [[]];\n  let currentLine = 0;\n\n  /**\n   *\n   * @param node\n   * @param parentType\n   */\n  function processNode(node, parentType) {\n    if (node.type === 'text') {\n      const textLines = node.content.split('\\n');\n\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n\n        // textLine.split(/ (?=[^!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]+)/).forEach((word) => {\n        textLine.split(' ').forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType || 'normal' });\n          }\n        });\n      });\n    } else if (node.type === 'strong' || node.type === 'em') {\n      node.content.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n\n  syntaxTree.forEach((treeNode) => {\n    if (treeNode.type === 'paragraph') {\n      treeNode.content.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n\n  return lines;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToHTML(markdown) {\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(markdown);\n\n  /**\n   *\n   * @param node\n   */\n  function output(node) {\n    if (node.type === 'text') {\n      return node.content.replace(/\\n/g, '<br/>');\n    } else if (node.type === 'strong') {\n      return `<strong>${node.content.map(output).join('')}</strong>`;\n    } else if (node.type === 'em') {\n      return `<em>${node.content.map(output).join('')}</em>`;\n    } else if (node.type === 'paragraph') {\n      return `<p>${node.content.map(output).join('')}</p>`;\n    } else {\n      return '';\n    }\n  }\n\n  return syntaxTree.map(output).join('');\n}\n","import { select } from 'd3';\nimport { log } from '../logger';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\nimport { decodeEntities } from '../mermaidAPI';\nimport { markdownToHTML, markdownToLines } from '../rendering-util/handle-markdown-text';\n/**\n * @param dom\n * @param styleFn\n */\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr('style', styleFn);\n  }\n}\n\n/**\n * @param element\n * @param {any} node\n * @param width\n * @param classes\n * @returns {SVGForeignObjectElement} Node\n */\nfunction addHtmlSpan(element, node, width, classes) {\n  const fo = element.append('foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  const div = fo.append('xhtml:div');\n  // const div = body.append('div');\n  // const div = fo.append('div');\n\n  const label = node.label;\n  const labelClass = node.isNode ? 'nodeLabel' : 'edgeLabel';\n  div.html(\n    `<span class=\"${labelClass} ${classes}\" ` +\n      (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : '') +\n      '>' +\n      label +\n      '</span>'\n  );\n\n  applyStyle(div, node.labelStyle);\n  div.style('display', 'table-cell');\n  div.style('white-space', 'nowrap');\n  div.style('max-width', width + 'px');\n  div.attr('xmlns', 'http://www.w3.org/1999/xhtml');\n\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style('display', 'table');\n    div.style('white-space', 'break-spaces');\n    div.style('width', width + 'px');\n    bbox = div.node().getBoundingClientRect();\n  }\n\n  fo.style('width', bbox.width);\n  fo.style('height', bbox.height);\n\n  return fo.node();\n}\n\n/**\n * Creates a tspan element with the specified attributes for text positioning.\n *\n * @param {object} textElement - The parent text element to append the tspan element.\n * @param {number} lineIndex - The index of the current line in the structuredText array.\n * @param {number} lineHeight - The line height value for the text.\n * @returns {object} The created tspan element.\n */\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement\n    .append('tspan')\n    .attr('class', 'text-outer-tspan')\n    .attr('x', 0)\n    .attr('y', lineIndex * lineHeight - 0.1 + 'em')\n    .attr('dy', lineHeight + 'em');\n}\n\n/**\n * Creates a formatted text element by breaking lines and applying styles based on\n * the given structuredText.\n *\n * @param {number} width - The maximum allowed width of the text.\n * @param {object} g - The parent group element to append the formatted text.\n * @param {Array} structuredText - The structured text data to format.\n * @param addBackground\n */\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append('g');\n  let bkg = labelGroup.insert('rect').attr('class', 'background');\n  const textElement = labelGroup.append('text').attr('y', '-10.1');\n  // .attr('dominant-baseline', 'middle')\n  // .attr('text-anchor', 'middle');\n  // .attr('text-anchor', 'middle');\n  let lineIndex = -1;\n  structuredText.forEach((line) => {\n    lineIndex++;\n    let tspan = createTspan(textElement, lineIndex, lineHeight);\n\n    let words = [...line].reverse();\n    let currentWord;\n    let wrappedLine = [];\n\n    while (words.length) {\n      currentWord = words.pop();\n      wrappedLine.push(currentWord);\n\n      updateTextContentAndStyles(tspan, wrappedLine);\n\n      if (tspan.node().getComputedTextLength() > width) {\n        wrappedLine.pop();\n        words.push(currentWord);\n\n        updateTextContentAndStyles(tspan, wrappedLine);\n\n        wrappedLine = [];\n        lineIndex++;\n        tspan = createTspan(textElement, lineIndex, lineHeight);\n      }\n    }\n  });\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg\n      .attr('x', -padding)\n      .attr('y', -padding)\n      .attr('width', bbox.width + 2 * padding)\n      .attr('height', bbox.height + 2 * padding);\n    // .style('fill', 'red');\n\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n\n/**\n * Updates the text content and styles of the given tspan element based on the\n * provided wrappedLine data.\n *\n * @param {object} tspan - The tspan element to update.\n * @param {Array} wrappedLine - The line data to apply to the tspan element.\n */\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text('');\n\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan\n      .append('tspan')\n      .attr('font-style', word.type === 'em' ? 'italic' : 'normal')\n      .attr('class', 'text-inner-tspan')\n      .attr('font-weight', word.type === 'strong' ? 'bold' : 'normal');\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(' ' + word.content);\n    }\n  });\n}\n\n/**\n *\n * @param el\n * @param {*} text\n * @param {*} param1\n * @param root0\n * @param root0.style\n * @param root0.isTitle\n * @param root0.classes\n * @param root0.useHtmlLabels\n * @param root0.isNode\n * @returns\n */\n// Note when using from flowcharts converting the API isNode means classes should be set accordingly. When using htmlLabels => to sett classes to'nodeLabel' when isNode=true otherwise 'edgeLabel'\n// When not using htmlLabels => to set classes to 'title-row' when isTitle=true otherwise 'title-row'\nexport const createText = (\n  el,\n  text = '',\n  {\n    style = '',\n    isTitle = false,\n    classes = '',\n    useHtmlLabels = true,\n    isNode = true,\n    width,\n    addSvgBackground = false,\n  } = {}\n) => {\n  log.info('createText', text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n    // text = text.replace(/\\\\n|\\n/g, '<br />');\n    const htmlText = markdownToHTML(text);\n    // log.info('markdo  wnToHTML' + text, markdownToHTML(text));\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(':', ' ')}'></i>`\n      ),\n      labelStyle: style.replace('fill:', 'color:'),\n    };\n    let vertexNode = addHtmlSpan(el, node, width, classes);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    let lastWord;\n    structuredText.forEach((line) => {\n      line.forEach((word) => {\n        if (special.includes(word.content) && lastWord) {\n          lastWord.content += word.content;\n          word.content = '';\n        }\n        lastWord = word;\n      });\n    });\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\n"],"names":[],"mappings":"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"}