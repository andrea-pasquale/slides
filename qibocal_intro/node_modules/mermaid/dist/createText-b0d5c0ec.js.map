{"version":3,"file":"createText-b0d5c0ec.js","sources":["../../../node_modules/.pnpm/@khanacademy+simple-markdown@0.8.6_wcqkhtmu7mswc6yz4uyexck3ty/node_modules/@khanacademy/simple-markdown/dist/es/index.js","../src/rendering-util/handle-markdown-text.js","../src/rendering-util/createText.js"],"sourcesContent":["/* eslint-disable prefer-spread, no-regex-spaces, no-unused-vars, guard-for-in, no-console, no-var */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n */\n// Flow Type Definitions:\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\n// End Flow Definitions\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n/**\n * Turn various whitespace into easy-to-process whitespace\n */\n\nvar preprocess = function preprocess(source) {\n  return source.replace(CR_NEWLINE_R, \"\\n\").replace(FORMFEED_R, \"\").replace(TAB_R, \"    \");\n};\n\nvar populateInitialState = function populateInitialState(givenState, defaultState) {\n  var state = givenState || {};\n\n  if (defaultState != null) {\n    for (var prop in defaultState) {\n      // $FlowFixMe\n      if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n        state[prop] = defaultState[prop];\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\n\n\nvar parserFor = function parserFor(rules, defaultState) {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  var ruleList = Object.keys(rules).filter(function (type) {\n    var rule = rules[type];\n\n    if (rule == null || rule.match == null) {\n      return false;\n    }\n\n    var order = rule.order;\n\n    if ((typeof order !== \"number\" || !isFinite(order)) && typeof console !== \"undefined\") {\n      console.warn(\"simple-markdown: Invalid order for rule `\" + type + \"`: \" + String(order));\n    }\n\n    return true;\n  });\n  ruleList.sort(function (typeA, typeB) {\n    var ruleA = rules[typeA];\n    var ruleB = rules[typeB];\n    var orderA = ruleA.order;\n    var orderB = ruleB.order; // First sort based on increasing order\n\n    if (orderA !== orderB) {\n      return orderA - orderB;\n    }\n\n    var secondaryOrderA = ruleA.quality ? 0 : 1;\n    var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n    if (secondaryOrderA !== secondaryOrderB) {\n      return secondaryOrderA - secondaryOrderB; // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1;\n    } else if (typeA > typeB) {\n      return 1;\n    } else {\n      // Rules should never have the same name,\n      // but this is provided for completeness.\n      return 0;\n    }\n  });\n  var latestState;\n\n  var nestedParse = function nestedParse(source, state) {\n    var result = [];\n    state = state || latestState;\n    latestState = state;\n\n    while (source) {\n      // store the best match, it's rule, and quality:\n      var ruleType = null;\n      var rule = null;\n      var capture = null;\n      var quality = NaN; // loop control variables:\n\n      var i = 0;\n      var currRuleType = ruleList[0]; // $FlowFixMe\n\n      var currRule = rules[currRuleType];\n\n      do {\n        var currOrder = currRule.order;\n        var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n        var currCapture = currRule.match(source, state, prevCaptureStr);\n\n        if (currCapture) {\n          var currQuality = currRule.quality ? currRule.quality(currCapture, state, prevCaptureStr) : 0; // This should always be true the first time because\n          // the initial quality is NaN (that's why there's the\n          // condition negation).\n\n          if (!(currQuality <= quality)) {\n            ruleType = currRuleType;\n            rule = currRule;\n            capture = currCapture;\n            quality = currQuality;\n          }\n        } // Move on to the next item.\n        // Note that this makes `currRule` be the next item\n\n\n        i++;\n        currRuleType = ruleList[i]; // $FlowFixMe\n\n        currRule = rules[currRuleType];\n      } while ( // keep looping while we're still within the ruleList\n      currRule && ( // if we don't have a match yet, continue\n      !capture || // or if we have a match, but the next rule is\n      // at the same order, and has a quality measurement\n      // functions, then this rule must have a quality\n      // measurement function (since they are sorted before\n      // those without), and we need to check if there is\n      // a better quality match\n      currRule.order === currOrder && currRule.quality)); // TODO(aria): Write tests for these\n\n\n      if (rule == null || capture == null) {\n        throw new Error(\"Could not find a matching rule for the below \" + \"content. The rule with highest `order` should \" + \"always match content provided to it. Check \" + \"the definition of `match` for '\" + ruleList[ruleList.length - 1] + \"'. It seems to not match the following source:\\n\" + source);\n      }\n\n      if (capture.index) {\n        // If present and non-zero, i.e. a non-^ regexp result:\n        throw new Error(\"`match` must return a capture starting at index 0 \" + \"(the current parse index). Did you forget a ^ at the \" + \"start of the RegExp?\");\n      }\n\n      var parsed = rule.parse(capture, nestedParse, state); // We maintain the same object here so that rules can\n      // store references to the objects they return and\n      // modify them later. (oops sorry! but this adds a lot\n      // of power--see reflinks.)\n\n      if (Array.isArray(parsed)) {\n        // $FlowFixMe\n        Array.prototype.push.apply(result, parsed);\n      } else {\n        if (parsed == null || typeof parsed !== \"object\") {\n          throw new Error(\"parse() function returned invalid parse result: '\".concat(parsed, \"'\"));\n        } // We also let rules override the default type of\n        // their parsed node if they would like to, so that\n        // there can be a single output function for all links,\n        // even if there are several rules to parse them.\n\n\n        if (parsed.type == null) {\n          // $FlowFixMe\n          parsed.type = ruleType;\n        }\n\n        result.push(parsed);\n      }\n\n      state.prevCapture = capture;\n      source = source.substring(state.prevCapture[0].length);\n    } // $FlowFixMe\n\n\n    return result;\n  };\n\n  var outerParse = function outerParse(source, state) {\n    latestState = populateInitialState(state, defaultState);\n\n    if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n      source = source + \"\\n\\n\";\n    } // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information). This stores\n    // the full regex capture object, if there is one.\n\n\n    latestState.prevCapture = null;\n    return nestedParse(preprocess(source), latestState);\n  }; // $FlowFixMe\n\n\n  return outerParse;\n}; // Creates a match function for an inline scoped element from a regex\n\n\nvar inlineRegex = function inlineRegex(regex) {\n  var match = function match(source, state, prevCapture) {\n    if (state.inline) {\n      // $FlowFixMe\n      return regex.exec(source);\n    } else {\n      return null;\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function for a block scoped element from a regex\n\n\nvar blockRegex = function blockRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    if (state.inline) {\n      return null;\n    } else {\n      return regex.exec(source);\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function from a regex, ignoring block/inline scope\n\n\nvar anyScopeRegex = function anyScopeRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    return regex.exec(source);\n  };\n\n  match.regex = regex;\n  return match;\n};\n\nvar TYPE_SYMBOL = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n\nvar reactElement = function reactElement(type, key, props) {\n  var element = {\n    $$typeof: TYPE_SYMBOL,\n    type: type,\n    key: key == null ? undefined : key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n  return element;\n};\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\n\n\nvar htmlTag = function htmlTag(tagName, content, attributes, isClosed) {\n  attributes = attributes || {};\n  isClosed = typeof isClosed !== \"undefined\" ? isClosed : true;\n  var attributeString = \"\";\n\n  for (var attr in attributes) {\n    var attribute = attributes[attr]; // Removes falsey attributes\n\n    if ( // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(attributes, attr) && attribute) {\n      attributeString += \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n    }\n  }\n\n  var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n  if (isClosed) {\n    return unclosedTag + content + \"</\" + tagName + \">\";\n  } else {\n    return unclosedTag;\n  }\n};\n\nvar EMPTY_PROPS = {};\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\n\nvar sanitizeUrl = function sanitizeUrl(url) {\n  if (url == null) {\n    return null;\n  }\n\n  try {\n    var prot = new URL(url, \"https://localhost\").protocol;\n\n    if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n      return null;\n    }\n  } catch (e) {\n    // invalid URLs should throw a TypeError\n    // see for instance: `new URL(\"\");`\n    return null;\n  }\n\n  return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"&\": \"&amp;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#x27;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#96;\"\n};\n\nvar sanitizeText = function sanitizeText(text) {\n  return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n    return SANITIZE_TEXT_CODES[chr];\n  });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function unescapeUrl(rawUrlString) {\n  return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n */\n\n\nvar parseInline = function parseInline(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = true;\n  var result = parse(content, state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseBlock = function parseBlock(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = false;\n  var result = parse(content + \"\\n\\n\", state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseCaptureInline = function parseCaptureInline(capture, parse, state) {\n  return {\n    content: parseInline(parse, capture[1], state)\n  };\n};\n\nvar ignoreCapture = function ignoreCapture() {\n  return {};\n}; // recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\n\n\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\"; // recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\n\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX); // recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\n\nvar LIST_ITEM_R = new RegExp(LIST_ITEM_PREFIX + \"[^\\\\n]*(?:\\\\n\" + \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\", \"gm\");\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g; // recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\n\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/; // check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\n\nvar LIST_R = new RegExp(\"^( *)(\" + LIST_BULLET + \") \" + \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" + \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" + // the \\\\s*$ here is so that we can parse the inside of nested\n// lists, where our content might end before we receive two `\\n`s\n\"|\\\\s*\\n*$)\");\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = function () {\n  var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n  var TABLE_CELL_END_TRIM = / *$/;\n  var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n  var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n  var TABLE_LEFT_ALIGN = /^ *:-+ *$/; // TODO: This needs a real type\n\n  var parseTableAlignCapture = function parseTableAlignCapture(alignCapture) {\n    if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n      return \"right\";\n    } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n      return \"center\";\n    } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n      return \"left\";\n    } else {\n      return null;\n    }\n  };\n\n  var parseTableAlign = function parseTableAlign(source, parse, state, trimEndSeparators) {\n    if (trimEndSeparators) {\n      source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n    }\n\n    var alignText = source.trim().split(\"|\");\n    return alignText.map(parseTableAlignCapture);\n  };\n\n  var parseTableRow = function parseTableRow(source, parse, state, trimEndSeparators) {\n    var prevInTable = state.inTable;\n    state.inTable = true;\n    var tableRow = parse(source.trim(), state);\n    state.inTable = prevInTable;\n    var cells = [[]];\n    tableRow.forEach(function (node, i) {\n      if (node.type === \"tableSeparator\") {\n        // Filter out empty table separators at the start/end:\n        if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n          // Split the current row:\n          cells.push([]);\n        }\n      } else {\n        if (node.type === \"text\" && (tableRow[i + 1] == null || tableRow[i + 1].type === \"tableSeparator\")) {\n          node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n        }\n\n        cells[cells.length - 1].push(node);\n      }\n    });\n    return cells;\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {SimpleMarkdown.State} state\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.ASTNode[][]}\n   */\n\n\n  var parseTableCells = function parseTableCells(source, parse, state, trimEndSeparators) {\n    var rowsText = source.trim().split(\"\\n\");\n    return rowsText.map(function (rowText) {\n      // $FlowFixMe\n      return parseTableRow(rowText, parse, state, trimEndSeparators);\n    });\n  };\n  /**\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.SingleNodeParseFunction}\n   */\n\n\n  var parseTable = function parseTable(trimEndSeparators) {\n    return function (capture, parse, state) {\n      state.inline = true;\n      var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n      var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n      var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n      state.inline = false;\n      return {\n        type: \"table\",\n        header: header,\n        align: align,\n        cells: cells\n      };\n    };\n  };\n\n  return {\n    parseTable: parseTable(true),\n    parseNpTable: parseTable(false),\n    TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n    NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n  };\n}();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE = \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function parseRef(capture, state, refNode) {\n  var ref = (capture[2] || capture[1]).replace(/\\s+/g, \" \").toLowerCase(); // We store information about previously seen defs on\n  // state._defs (_ to deconflict with client-defined\n  // state). If the def for this reflink/refimage has\n  // already been seen, we can use its target/source\n  // and title here:\n\n  if (state._defs && state._defs[ref]) {\n    var def = state._defs[ref]; // `refNode` can be a link or an image. Both use\n    // target and title properties.\n\n    refNode.target = def.target;\n    refNode.title = def.title;\n  } // In case we haven't seen our def yet (or if someone\n  // overwrites that def later on), we add this node\n  // to the list of ref nodes for that def. Then, when\n  // we find the def, we can modify this link/image AST\n  // node :).\n  // I'm sorry.\n\n\n  state._refs = state._refs || {};\n  state._refs[ref] = state._refs[ref] || [];\n\n  state._refs[ref].push(refNode);\n\n  return refNode;\n};\n\nvar currOrder = 0;\nvar defaultRules = {\n  Array: {\n    react: function react(arr, output, state) {\n      var oldKey = state.key;\n      var result = []; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0, key = 0; i < arr.length; i++, key++) {\n        // `key` is our numerical `state.key`, which we increment for\n        // every output node, but don't change for joined text nodes.\n        // (i, however, must change for joined text nodes)\n        state.key = \"\" + i;\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result.push(output(node, state));\n      }\n\n      state.key = oldKey;\n      return result;\n    },\n    html: function html(arr, output, state) {\n      var result = \"\"; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0; i < arr.length; i++) {\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result += output(node, state);\n      }\n\n      return result;\n    }\n  },\n  heading: {\n    order: currOrder++,\n    match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n    parse: function (_parse) {\n      function parse(_x, _x2, _x3) {\n        return _parse.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        level: capture[1].length,\n        content: parseInline(parse, capture[2].trim(), state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"h\" + node.level, state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"h\" + node.level, output(node.content, state));\n    }\n  },\n  nptable: {\n    order: currOrder++,\n    match: blockRegex(TABLES.NPTABLE_REGEX),\n    parse: TABLES.parseNpTable,\n    react: null,\n    html: null\n  },\n  lheading: {\n    order: currOrder++,\n    match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n    parse: function (_parse2) {\n      function parse(_x4, _x5, _x6) {\n        return _parse2.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse2.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"heading\",\n        level: capture[2] === \"=\" ? 1 : 2,\n        content: parseInline(parse, capture[1], state)\n      };\n    }),\n    react: null,\n    html: null\n  },\n  hr: {\n    order: currOrder++,\n    match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"hr\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<hr>\";\n    }\n  },\n  codeBlock: {\n    order: currOrder++,\n    match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n    parse: function (_parse3) {\n      function parse(_x7, _x8, _x9) {\n        return _parse3.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse3.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^    /gm, \"\").replace(/\\n+$/, \"\");\n      return {\n        lang: undefined,\n        content: content\n      };\n    }),\n    react: function react(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      return reactElement(\"pre\", state.key, {\n        children: reactElement(\"code\", null, {\n          className: className,\n          children: node.content\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n        class: className\n      });\n      return htmlTag(\"pre\", codeBlock);\n    }\n  },\n  fence: {\n    order: currOrder++,\n    match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n    parse: function (_parse4) {\n      function parse(_x10, _x11, _x12) {\n        return _parse4.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse4.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"codeBlock\",\n        lang: capture[2] || undefined,\n        content: capture[3]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  blockQuote: {\n    order: currOrder++,\n    match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n    parse: function (_parse5) {\n      function parse(_x13, _x14, _x15) {\n        return _parse5.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse5.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^ *> ?/gm, \"\");\n      return {\n        content: parse(content, state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"blockquote\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"blockquote\", output(node.content, state));\n    }\n  },\n  list: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      // We only want to break into a list if we are at the start of a\n      // line. This is to avoid parsing \"hi * there\" with \"* there\"\n      // becoming a part of a list.\n      // You might wonder, \"but that's inline, so of course it wouldn't\n      // start a list?\". You would be correct! Except that some of our\n      // lists can be inline, because they might be inside another list,\n      // in which case we can parse with inline scope, but need to allow\n      // nested lists inside this inline scope.\n      var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n      var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n      var isListBlock = state._list || !state.inline;\n\n      if (isStartOfLineCapture && isListBlock) {\n        source = isStartOfLineCapture[1] + source;\n        return LIST_R.exec(source);\n      } else {\n        return null;\n      }\n    },\n    parse: function (_parse6) {\n      function parse(_x16, _x17, _x18) {\n        return _parse6.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse6.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var bullet = capture[2];\n      var ordered = bullet.length > 1;\n      var start = ordered ? +bullet : undefined;\n      var items = capture[0].replace(LIST_BLOCK_END_R, \"\\n\").match(LIST_ITEM_R); // We know this will match here, because of how the regexes are\n      // defined\n\n      var lastItemWasAParagraph = false;\n      var itemContent = items.map(function (item, i) {\n        // We need to see how far indented this item is:\n        var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n        var space = prefixCapture ? prefixCapture[0].length : 0; // And then we construct a regex to \"unindent\" the subsequent\n        // lines of the items by that amount:\n\n        var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\"); // Before processing the item, we need a couple things\n\n        var content = item // remove indents on trailing lines:\n        .replace(spaceRegex, \"\") // remove the bullet:\n        .replace(LIST_ITEM_PREFIX_R, \"\"); // I'm not sur4 why this is necessary again?\n        // Handling \"loose\" lists, like:\n        //\n        //  * this is wrapped in a paragraph\n        //\n        //  * as is this\n        //\n        //  * as is this\n\n        var isLastItem = i === items.length - 1;\n        var containsBlocks = content.indexOf(\"\\n\\n\") !== -1; // Any element in a list is a block if it contains multiple\n        // newlines. The last element in the list can also be a block\n        // if the previous item in the list was a block (this is\n        // because non-last items in the list can end with \\n\\n, but\n        // the last item can't, so we just \"inherit\" this property\n        // from our previous element).\n\n        var thisItemIsAParagraph = containsBlocks || isLastItem && lastItemWasAParagraph;\n        lastItemWasAParagraph = thisItemIsAParagraph; // backup our state for restoration afterwards. We're going to\n        // want to set state._list to true, and state.inline depending\n        // on our list's looseness.\n\n        var oldStateInline = state.inline;\n        var oldStateList = state._list;\n        state._list = true; // Parse inline if we're in a tight list, or block if we're in\n        // a loose list.\n\n        var adjustedContent;\n\n        if (thisItemIsAParagraph) {\n          state.inline = false;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n        } else {\n          state.inline = true;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n        }\n\n        var result = parse(adjustedContent, state); // Restore our state before returning\n\n        state.inline = oldStateInline;\n        state._list = oldStateList;\n        return result;\n      });\n      return {\n        ordered: ordered,\n        start: start,\n        items: itemContent\n      };\n    }),\n    react: function react(node, output, state) {\n      var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n      return reactElement(ListWrapper, state.key, {\n        start: node.start,\n        children: node.items.map(function (item, i) {\n          return reactElement(\"li\", \"\" + i, {\n            children: output(item, state)\n          });\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var listItems = node.items.map(function (item) {\n        return htmlTag(\"li\", output(item, state));\n      }).join(\"\");\n      var listTag = node.ordered ? \"ol\" : \"ul\";\n      var attributes = {\n        start: node.start\n      };\n      return htmlTag(listTag, listItems, attributes);\n    }\n  },\n  def: {\n    order: currOrder++,\n    // TODO(aria): This will match without a blank line before the next\n    // block element, which is inconsistent with most of the rest of\n    // simple-markdown.\n    match: blockRegex(/^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/),\n    parse: function (_parse7) {\n      function parse(_x19, _x20, _x21) {\n        return _parse7.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse7.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var def = capture[1].replace(/\\s+/g, \" \").toLowerCase();\n      var target = capture[2];\n      var title = capture[3]; // Look for previous links/images using this def\n      // If any links/images using this def have already been declared,\n      // they will have added themselves to the state._refs[def] list\n      // (_ to deconflict with client-defined state). We look through\n      // that list of reflinks for this def, and modify those AST nodes\n      // with our newly found information now.\n      // Sorry :(.\n\n      if (state._refs && state._refs[def]) {\n        // `refNode` can be a link or an image\n        state._refs[def].forEach(function (refNode) {\n          refNode.target = target;\n          refNode.title = title;\n        });\n      } // Add this def to our map of defs for any future links/images\n      // In case we haven't found any or all of the refs referring to\n      // this def yet, we add our def to the table of known defs, so\n      // that future reflinks can modify themselves appropriately with\n      // this information.\n\n\n      state._defs = state._defs || {};\n      state._defs[def] = {\n        target: target,\n        title: title\n      }; // return the relevant parsed information\n      // for debugging only.\n\n      return {\n        def: def,\n        target: target,\n        title: title\n      };\n    }),\n    react: function react() {\n      return null;\n    },\n    html: function html() {\n      return \"\";\n    }\n  },\n  table: {\n    order: currOrder++,\n    match: blockRegex(TABLES.TABLE_REGEX),\n    parse: TABLES.parseTable,\n    react: function react(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? {} : {\n          textAlign: node.align[colIndex]\n        };\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return reactElement(\"th\", \"\" + i, {\n          style: getStyle(i),\n          scope: \"col\",\n          children: output(content, state)\n        });\n      });\n      var rows = node.cells.map(function (row, r) {\n        return reactElement(\"tr\", \"\" + r, {\n          children: row.map(function (content, c) {\n            return reactElement(\"td\", \"\" + c, {\n              style: getStyle(c),\n              children: output(content, state)\n            });\n          })\n        });\n      });\n      return reactElement(\"table\", state.key, {\n        children: [reactElement(\"thead\", \"thead\", {\n          children: reactElement(\"tr\", null, {\n            children: headers\n          })\n        }), reactElement(\"tbody\", \"tbody\", {\n          children: rows\n        })]\n      });\n    },\n    html: function html(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? \"\" : \"text-align:\" + node.align[colIndex] + \";\";\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return htmlTag(\"th\", output(content, state), {\n          style: getStyle(i),\n          scope: \"col\"\n        });\n      }).join(\"\");\n      var rows = node.cells.map(function (row) {\n        var cols = row.map(function (content, c) {\n          return htmlTag(\"td\", output(content, state), {\n            style: getStyle(c)\n          });\n        }).join(\"\");\n        return htmlTag(\"tr\", cols);\n      }).join(\"\");\n      var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n      var tbody = htmlTag(\"tbody\", rows);\n      return htmlTag(\"table\", thead + tbody);\n    }\n  },\n  newline: {\n    order: currOrder++,\n    match: blockRegex(/^(?:\\n *)*\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return \"\\n\";\n    },\n    html: function html(node, output, state) {\n      return \"\\n\";\n    }\n  },\n  paragraph: {\n    order: currOrder++,\n    match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"div\", state.key, {\n        className: \"paragraph\",\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        class: \"paragraph\"\n      };\n      return htmlTag(\"div\", output(node.content, state), attributes);\n    }\n  },\n  escape: {\n    order: currOrder++,\n    // We don't allow escaping numbers, letters, or spaces here so that\n    // backslashes used in plain text still get rendered. But allowing\n    // escaping anything else provides a very flexible escape mechanism,\n    // regardless of how this grammar is extended.\n    match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n    parse: function (_parse8) {\n      function parse(_x22, _x23, _x24) {\n        return _parse8.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse8.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"text\",\n        content: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  tableSeparator: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      if (!state.inTable) {\n        return null;\n      }\n\n      return /^ *\\| */.exec(source);\n    },\n    parse: function parse() {\n      return {\n        type: \"tableSeparator\"\n      };\n    },\n    // These shouldn't be reached, but in case they are, be reasonable:\n    react: function react() {\n      return \" | \";\n    },\n    html: function html() {\n      return \" &vert; \";\n    }\n  },\n  autolink: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n    parse: function (_parse9) {\n      function parse(_x25, _x26, _x27) {\n        return _parse9.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse9.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  mailto: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n    parse: function (_parse10) {\n      function parse(_x28, _x29, _x30) {\n        return _parse10.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse10.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var address = capture[1];\n      var target = capture[1]; // Check for a `mailto:` already existing in the link:\n\n      if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n        target = \"mailto:\" + target;\n      }\n\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: address\n        }],\n        target: target\n      };\n    }),\n    react: null,\n    html: null\n  },\n  url: {\n    order: currOrder++,\n    match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n    parse: function (_parse11) {\n      function parse(_x31, _x32, _x33) {\n        return _parse11.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse11.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1],\n        title: undefined\n      };\n    }),\n    react: null,\n    html: null\n  },\n  link: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse12) {\n      function parse(_x34, _x35, _x36) {\n        return _parse12.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse12.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var link = {\n        content: parse(capture[1], state),\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return link;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"a\", state.key, {\n        href: sanitizeUrl(node.target),\n        title: node.title,\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        href: sanitizeUrl(node.target),\n        title: node.title\n      };\n      return htmlTag(\"a\", output(node.content, state), attributes);\n    }\n  },\n  image: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse13) {\n      function parse(_x37, _x38, _x39) {\n        return _parse13.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse13.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var image = {\n        alt: capture[1],\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return image;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"img\", state.key, {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      };\n      return htmlTag(\"img\", \"\", attributes, false);\n    }\n  },\n  reflink: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse14) {\n      function parse(_x40, _x41, _x42) {\n        return _parse14.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse14.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"link\",\n        content: parse(capture[1], state)\n      });\n    }),\n    react: null,\n    html: null\n  },\n  refimage: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse15) {\n      function parse(_x43, _x44, _x45) {\n        return _parse15.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse15.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"image\",\n        alt: capture[1]\n      });\n    }),\n    react: null,\n    html: null\n  },\n  em: {\n    order: currOrder\n    /* same as strong/u */\n    ,\n    match: inlineRegex(new RegExp( // only match _s surrounding words.\n    \"^\\\\b_\" + \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" + \"\\\\b\" + // Or match *s:\n    \"|\" + // Only match *s that are followed by a non-space:\n    \"^\\\\*(?=\\\\S)(\" + // Match at least one of:\n    \"(?:\" + //  - `**`: so that bolds inside italics don't close the\n    //          italics\n    \"\\\\*\\\\*|\" + //  - escape sequence: so escaped *s don't close us\n    \"\\\\\\\\[\\\\s\\\\S]|\" + //  - whitespace: followed by a non-* (we don't\n    //          want ' *' to close an italics--it might\n    //          start a list)\n    \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" + //  - non-whitespace, non-*, non-backslash characters\n    \"[^\\\\s\\\\*\\\\\\\\]\" + \")+?\" + // followed by a non-space, non-* then *\n    \")\\\\*(?!\\\\*)\")),\n    quality: function quality(capture) {\n      // precedence by length, `em` wins ties:\n      return capture[0].length + 0.2;\n    },\n    parse: function (_parse16) {\n      function parse(_x46, _x47, _x48) {\n        return _parse16.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse16.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: parse(capture[2] || capture[1], state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"em\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"em\", output(node.content, state));\n    }\n  },\n  strong: {\n    order: currOrder\n    /* same as em */\n    ,\n    match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n    quality: function quality(capture) {\n      // precedence by length, wins ties vs `u`:\n      return capture[0].length + 0.1;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"strong\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"strong\", output(node.content, state));\n    }\n  },\n  u: {\n    order: currOrder++\n    /* same as em&strong; increment for next rule */\n    ,\n    match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n    quality: function quality(capture) {\n      // precedence by length, loses all ties\n      return capture[0].length;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"u\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"u\", output(node.content, state));\n    }\n  },\n  del: {\n    order: currOrder++,\n    match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"del\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"del\", output(node.content, state));\n    }\n  },\n  inlineCode: {\n    order: currOrder++,\n    match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n    parse: function (_parse17) {\n      function parse(_x49, _x50, _x51) {\n        return _parse17.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse17.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"code\", state.key, {\n        children: node.content\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"code\", sanitizeText(node.content));\n    }\n  },\n  br: {\n    order: currOrder++,\n    match: anyScopeRegex(/^ {2,}\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"br\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<br>\";\n    }\n  },\n  text: {\n    order: currOrder++,\n    // Here we look for anything followed by non-symbols,\n    // double newlines, or double-space-newlines\n    // We break on any symbol characters so that this grammar\n    // is easy to extend without needing to modify this regex\n    match: anyScopeRegex(/^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/),\n    parse: function (_parse18) {\n      function parse(_x52, _x53, _x54) {\n        return _parse18.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse18.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[0]\n      };\n    }),\n    react: function react(node, output, state) {\n      return node.content;\n    },\n    html: function html(node, output, state) {\n      return sanitizeText(node.content);\n    }\n  }\n};\n/** (deprecated) */\n\nvar ruleOutput = function ruleOutput( // $FlowFixMe\nrules, property) {\n  if (!property && typeof console !== \"undefined\") {\n    console.warn(\"simple-markdown ruleOutput should take 'react' or \" + \"'html' as the second argument.\");\n  }\n\n  var nestedRuleOutput = function nestedRuleOutput(ast, outputFunc, state) {\n    return rules[ast.type][property](ast, outputFunc, state);\n  };\n\n  return nestedRuleOutput;\n};\n/** (deprecated)\n */\n\n\nvar reactFor = function reactFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      var oldKey = state.key;\n      var result = []; // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n\n      var lastResult = null;\n\n      for (var i = 0; i < ast.length; i++) {\n        state.key = \"\" + i;\n        var nodeOut = nestedOutput(ast[i], state);\n\n        if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n          lastResult = lastResult + nodeOut;\n          result[result.length - 1] = lastResult;\n        } else {\n          result.push(nodeOut);\n          lastResult = nodeOut;\n        }\n      }\n\n      state.key = oldKey;\n      return result;\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n/** (deprecated)\n */\n\n\nvar htmlFor = function htmlFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      return ast.map(function (node) {\n        return nestedOutput(node, state);\n      }).join(\"\");\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n\nvar outputFor = function outputFor(rules, property) {\n  var defaultState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!property) {\n    throw new Error(\"simple-markdown: outputFor: `property` must be \" + \"defined. \" + \"if you just upgraded, you probably need to replace `outputFor` \" + \"with `reactFor`\");\n  }\n\n  var latestState; // $FlowFixMe[incompatible-type]\n\n  var arrayRule = rules.Array || defaultRules.Array; // Tricks to convince tsc that this var is not null:\n\n  var arrayRuleCheck = arrayRule[property];\n\n  if (!arrayRuleCheck) {\n    throw new Error(\"simple-markdown: outputFor: to join nodes of type `\" + property + \"` you must provide an `Array:` joiner rule with that type, \" + \"Please see the docs for details on specifying an Array rule.\");\n  }\n\n  var arrayRuleOutput = arrayRuleCheck;\n\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || latestState;\n    latestState = state;\n\n    if (Array.isArray(ast)) {\n      return arrayRuleOutput(ast, nestedOutput, state);\n    } else {\n      return rules[ast.type][property](ast, nestedOutput, state);\n    }\n  };\n\n  var outerOutput = function outerOutput(ast, state) {\n    latestState = populateInitialState(state, defaultState);\n    return nestedOutput(ast, latestState);\n  };\n\n  return outerOutput;\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultRawParse = parserFor(defaultRules);\n\nvar defaultBlockParse = function defaultBlockParse(source, state) {\n  state = state || {};\n  state.inline = false;\n  return defaultRawParse(source, state);\n};\n\nvar defaultInlineParse = function defaultInlineParse(source, state) {\n  state = state || {};\n  state.inline = true;\n  return defaultRawParse(source, state);\n};\n\nvar defaultImplicitParse = function defaultImplicitParse(source, state) {\n  var isBlock = BLOCK_END_R.test(source);\n  state = state || {};\n  state.inline = !isBlock;\n  return defaultRawParse(source, state);\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultReactOutput = outputFor(defaultRules, \"react\"); // $FlowFixMe[incompatible-call]\n\nvar defaultHtmlOutput = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function markdownToReact(source, state) {\n  return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n\nvar markdownToHtml = function markdownToHtml(source, state) {\n  return defaultHtmlOutput(defaultBlockParse(source, state), state);\n}; // TODO: This needs definition\n\n\nvar ReactMarkdown = function ReactMarkdown(props) {\n  var divProps = {};\n\n  for (var prop in props) {\n    if (prop !== \"source\" && // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(props, prop)) {\n      divProps[prop] = props[prop];\n    }\n  }\n\n  divProps.children = markdownToReact(props.source);\n  return reactElement(\"div\", null, divProps);\n};\n\n// $FlowFixMe\nvar SimpleMarkdown = {\n  defaultRules: defaultRules,\n  parserFor: parserFor,\n  outputFor: outputFor,\n  inlineRegex: inlineRegex,\n  blockRegex: blockRegex,\n  anyScopeRegex: anyScopeRegex,\n  parseInline: parseInline,\n  parseBlock: parseBlock,\n  // default wrappers:\n  markdownToReact: markdownToReact,\n  markdownToHtml: markdownToHtml,\n  ReactMarkdown: ReactMarkdown,\n  defaultBlockParse: defaultBlockParse,\n  defaultInlineParse: defaultInlineParse,\n  defaultImplicitParse: defaultImplicitParse,\n  defaultReactOutput: defaultReactOutput,\n  defaultHtmlOutput: defaultHtmlOutput,\n  preprocess: preprocess,\n  sanitizeText: sanitizeText,\n  sanitizeUrl: sanitizeUrl,\n  unescapeUrl: unescapeUrl,\n  htmlTag: htmlTag,\n  reactElement: reactElement,\n  // deprecated:\n  defaultRawParse: defaultRawParse,\n  ruleOutput: ruleOutput,\n  reactFor: reactFor,\n  htmlFor: htmlFor,\n  defaultParse: function defaultParse() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultParse is deprecated, please use `defaultImplicitParse`\");\n    }\n\n    return defaultImplicitParse.apply(null, arguments);\n  },\n  defaultOutput: function defaultOutput() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultOutput is deprecated, please use `defaultReactOutput`\");\n    }\n\n    return defaultReactOutput.apply(null, arguments);\n  }\n};\n\nexport { SimpleMarkdown as default };\n//# sourceMappingURL=index.js.map\n","import SimpleMarkdown from '@khanacademy/simple-markdown';\n\n/**\n *\n * @param markdown\n */\nfunction preprocessMarkdown(markdown) {\n  // Replace multiple newlines with a single newline\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, '\\n');\n  // Remove extra spaces at the beginning of each line\n  const withoutExtraSpaces = withoutMultipleNewlines.replace(/^\\s+/gm, '');\n  return withoutExtraSpaces;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(preprocessedMarkdown);\n\n  let lines = [[]];\n  let currentLine = 0;\n\n  /**\n   *\n   * @param node\n   * @param parentType\n   */\n  function processNode(node, parentType) {\n    if (node.type === 'text') {\n      const textLines = node.content.split('\\n');\n\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n\n        // textLine.split(/ (?=[^!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]+)/).forEach((word) => {\n        textLine.split(' ').forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType || 'normal' });\n          }\n        });\n      });\n    } else if (node.type === 'strong' || node.type === 'em') {\n      node.content.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n\n  syntaxTree.forEach((treeNode) => {\n    if (treeNode.type === 'paragraph') {\n      treeNode.content.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n\n  return lines;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToHTML(markdown) {\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(markdown);\n\n  /**\n   *\n   * @param node\n   */\n  function output(node) {\n    if (node.type === 'text') {\n      return node.content.replace(/\\n/g, '<br/>');\n    } else if (node.type === 'strong') {\n      return `<strong>${node.content.map(output).join('')}</strong>`;\n    } else if (node.type === 'em') {\n      return `<em>${node.content.map(output).join('')}</em>`;\n    } else if (node.type === 'paragraph') {\n      return `<p>${node.content.map(output).join('')}</p>`;\n    } else {\n      return '';\n    }\n  }\n\n  return syntaxTree.map(output).join('');\n}\n","import { select } from 'd3';\nimport { log } from '../logger';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\nimport { decodeEntities } from '../mermaidAPI';\nimport { markdownToHTML, markdownToLines } from '../rendering-util/handle-markdown-text';\n/**\n * @param dom\n * @param styleFn\n */\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr('style', styleFn);\n  }\n}\n\n/**\n * @param element\n * @param {any} node\n * @param width\n * @param classes\n * @returns {SVGForeignObjectElement} Node\n */\nfunction addHtmlSpan(element, node, width, classes) {\n  const fo = element.append('foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  const div = fo.append('xhtml:div');\n  // const div = body.append('div');\n  // const div = fo.append('div');\n\n  const label = node.label;\n  const labelClass = node.isNode ? 'nodeLabel' : 'edgeLabel';\n  div.html(\n    `<span class=\"${labelClass} ${classes}\" ` +\n      (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : '') +\n      '>' +\n      label +\n      '</span>'\n  );\n\n  applyStyle(div, node.labelStyle);\n  div.style('display', 'table-cell');\n  div.style('white-space', 'nowrap');\n  div.style('max-width', width + 'px');\n  div.attr('xmlns', 'http://www.w3.org/1999/xhtml');\n\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style('display', 'table');\n    div.style('white-space', 'break-spaces');\n    div.style('width', width + 'px');\n    bbox = div.node().getBoundingClientRect();\n  }\n\n  fo.style('width', bbox.width);\n  fo.style('height', bbox.height);\n\n  return fo.node();\n}\n\n/**\n * Creates a tspan element with the specified attributes for text positioning.\n *\n * @param {object} textElement - The parent text element to append the tspan element.\n * @param {number} lineIndex - The index of the current line in the structuredText array.\n * @param {number} lineHeight - The line height value for the text.\n * @returns {object} The created tspan element.\n */\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement\n    .append('tspan')\n    .attr('class', 'text-outer-tspan')\n    .attr('x', 0)\n    .attr('y', lineIndex * lineHeight - 0.1 + 'em')\n    .attr('dy', lineHeight + 'em');\n}\n\n/**\n * Creates a formatted text element by breaking lines and applying styles based on\n * the given structuredText.\n *\n * @param {number} width - The maximum allowed width of the text.\n * @param {object} g - The parent group element to append the formatted text.\n * @param {Array} structuredText - The structured text data to format.\n * @param addBackground\n */\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append('g');\n  let bkg = labelGroup.insert('rect').attr('class', 'background');\n  const textElement = labelGroup.append('text').attr('y', '-10.1');\n  // .attr('dominant-baseline', 'middle')\n  // .attr('text-anchor', 'middle');\n  // .attr('text-anchor', 'middle');\n  let lineIndex = -1;\n  structuredText.forEach((line) => {\n    lineIndex++;\n    let tspan = createTspan(textElement, lineIndex, lineHeight);\n\n    let words = [...line].reverse();\n    let currentWord;\n    let wrappedLine = [];\n\n    while (words.length) {\n      currentWord = words.pop();\n      wrappedLine.push(currentWord);\n\n      updateTextContentAndStyles(tspan, wrappedLine);\n\n      if (tspan.node().getComputedTextLength() > width) {\n        wrappedLine.pop();\n        words.push(currentWord);\n\n        updateTextContentAndStyles(tspan, wrappedLine);\n\n        wrappedLine = [];\n        lineIndex++;\n        tspan = createTspan(textElement, lineIndex, lineHeight);\n      }\n    }\n  });\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg\n      .attr('x', -padding)\n      .attr('y', -padding)\n      .attr('width', bbox.width + 2 * padding)\n      .attr('height', bbox.height + 2 * padding);\n    // .style('fill', 'red');\n\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n\n/**\n * Updates the text content and styles of the given tspan element based on the\n * provided wrappedLine data.\n *\n * @param {object} tspan - The tspan element to update.\n * @param {Array} wrappedLine - The line data to apply to the tspan element.\n */\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text('');\n\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan\n      .append('tspan')\n      .attr('font-style', word.type === 'em' ? 'italic' : 'normal')\n      .attr('class', 'text-inner-tspan')\n      .attr('font-weight', word.type === 'strong' ? 'bold' : 'normal');\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(' ' + word.content);\n    }\n  });\n}\n\n/**\n *\n * @param el\n * @param {*} text\n * @param {*} param1\n * @param root0\n * @param root0.style\n * @param root0.isTitle\n * @param root0.classes\n * @param root0.useHtmlLabels\n * @param root0.isNode\n * @returns\n */\n// Note when using from flowcharts converting the API isNode means classes should be set accordingly. When using htmlLabels => to sett classes to'nodeLabel' when isNode=true otherwise 'edgeLabel'\n// When not using htmlLabels => to set classes to 'title-row' when isTitle=true otherwise 'title-row'\nexport const createText = (\n  el,\n  text = '',\n  {\n    style = '',\n    isTitle = false,\n    classes = '',\n    useHtmlLabels = true,\n    isNode = true,\n    width,\n    addSvgBackground = false,\n  } = {}\n) => {\n  log.info('createText', text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n    // text = text.replace(/\\\\n|\\n/g, '<br />');\n    const htmlText = markdownToHTML(text);\n    // log.info('markdo  wnToHTML' + text, markdownToHTML(text));\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(':', ' ')}'></i>`\n      ),\n      labelStyle: style.replace('fill:', 'color:'),\n    };\n    let vertexNode = addHtmlSpan(el, node, width, classes);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    let lastWord;\n    structuredText.forEach((line) => {\n      line.forEach((word) => {\n        if (special.includes(word.content) && lastWord) {\n          lastWord.content += word.content;\n          word.content = '';\n        }\n        lastWord = word;\n      });\n    });\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\n"],"names":["preprocess","populateInitialState","parserFor","nestedParse","quality","currOrder","outerParse","inlineRegex","match","blockRegex","anyScopeRegex","reactElement","htmlTag","sanitizeUrl","sanitizeText","unescapeUrl","parseInline","parse","parseBlock","parseCaptureInline","ignoreCapture","parseTableAlignCapture","parseTableAlign","parseTableRow","parseTableCells","parseTable","parseRef","react","html","getStyle","ruleOutput","nestedRuleOutput","reactFor","nestedOutput","htmlFor","outputFor","outerOutput","defaultBlockParse","defaultInlineParse","defaultImplicitParse","markdownToReact","markdownToHtml","ReactMarkdown"],"mappings":"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"}