{"version":3,"file":"createText-23817c58.js","sources":["../../../node_modules/.pnpm/@khanacademy+simple-markdown@0.8.6_wcqkhtmu7mswc6yz4uyexck3ty/node_modules/@khanacademy/simple-markdown/dist/es/index.js","../src/rendering-util/handle-markdown-text.js","../src/rendering-util/createText.js"],"sourcesContent":["/* eslint-disable prefer-spread, no-regex-spaces, no-unused-vars, guard-for-in, no-console, no-var */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n */\n// Flow Type Definitions:\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\n// End Flow Definitions\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n/**\n * Turn various whitespace into easy-to-process whitespace\n */\n\nvar preprocess = function preprocess(source) {\n  return source.replace(CR_NEWLINE_R, \"\\n\").replace(FORMFEED_R, \"\").replace(TAB_R, \"    \");\n};\n\nvar populateInitialState = function populateInitialState(givenState, defaultState) {\n  var state = givenState || {};\n\n  if (defaultState != null) {\n    for (var prop in defaultState) {\n      // $FlowFixMe\n      if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n        state[prop] = defaultState[prop];\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\n\n\nvar parserFor = function parserFor(rules, defaultState) {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  var ruleList = Object.keys(rules).filter(function (type) {\n    var rule = rules[type];\n\n    if (rule == null || rule.match == null) {\n      return false;\n    }\n\n    var order = rule.order;\n\n    if ((typeof order !== \"number\" || !isFinite(order)) && typeof console !== \"undefined\") {\n      console.warn(\"simple-markdown: Invalid order for rule `\" + type + \"`: \" + String(order));\n    }\n\n    return true;\n  });\n  ruleList.sort(function (typeA, typeB) {\n    var ruleA = rules[typeA];\n    var ruleB = rules[typeB];\n    var orderA = ruleA.order;\n    var orderB = ruleB.order; // First sort based on increasing order\n\n    if (orderA !== orderB) {\n      return orderA - orderB;\n    }\n\n    var secondaryOrderA = ruleA.quality ? 0 : 1;\n    var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n    if (secondaryOrderA !== secondaryOrderB) {\n      return secondaryOrderA - secondaryOrderB; // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1;\n    } else if (typeA > typeB) {\n      return 1;\n    } else {\n      // Rules should never have the same name,\n      // but this is provided for completeness.\n      return 0;\n    }\n  });\n  var latestState;\n\n  var nestedParse = function nestedParse(source, state) {\n    var result = [];\n    state = state || latestState;\n    latestState = state;\n\n    while (source) {\n      // store the best match, it's rule, and quality:\n      var ruleType = null;\n      var rule = null;\n      var capture = null;\n      var quality = NaN; // loop control variables:\n\n      var i = 0;\n      var currRuleType = ruleList[0]; // $FlowFixMe\n\n      var currRule = rules[currRuleType];\n\n      do {\n        var currOrder = currRule.order;\n        var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n        var currCapture = currRule.match(source, state, prevCaptureStr);\n\n        if (currCapture) {\n          var currQuality = currRule.quality ? currRule.quality(currCapture, state, prevCaptureStr) : 0; // This should always be true the first time because\n          // the initial quality is NaN (that's why there's the\n          // condition negation).\n\n          if (!(currQuality <= quality)) {\n            ruleType = currRuleType;\n            rule = currRule;\n            capture = currCapture;\n            quality = currQuality;\n          }\n        } // Move on to the next item.\n        // Note that this makes `currRule` be the next item\n\n\n        i++;\n        currRuleType = ruleList[i]; // $FlowFixMe\n\n        currRule = rules[currRuleType];\n      } while ( // keep looping while we're still within the ruleList\n      currRule && ( // if we don't have a match yet, continue\n      !capture || // or if we have a match, but the next rule is\n      // at the same order, and has a quality measurement\n      // functions, then this rule must have a quality\n      // measurement function (since they are sorted before\n      // those without), and we need to check if there is\n      // a better quality match\n      currRule.order === currOrder && currRule.quality)); // TODO(aria): Write tests for these\n\n\n      if (rule == null || capture == null) {\n        throw new Error(\"Could not find a matching rule for the below \" + \"content. The rule with highest `order` should \" + \"always match content provided to it. Check \" + \"the definition of `match` for '\" + ruleList[ruleList.length - 1] + \"'. It seems to not match the following source:\\n\" + source);\n      }\n\n      if (capture.index) {\n        // If present and non-zero, i.e. a non-^ regexp result:\n        throw new Error(\"`match` must return a capture starting at index 0 \" + \"(the current parse index). Did you forget a ^ at the \" + \"start of the RegExp?\");\n      }\n\n      var parsed = rule.parse(capture, nestedParse, state); // We maintain the same object here so that rules can\n      // store references to the objects they return and\n      // modify them later. (oops sorry! but this adds a lot\n      // of power--see reflinks.)\n\n      if (Array.isArray(parsed)) {\n        // $FlowFixMe\n        Array.prototype.push.apply(result, parsed);\n      } else {\n        if (parsed == null || typeof parsed !== \"object\") {\n          throw new Error(\"parse() function returned invalid parse result: '\".concat(parsed, \"'\"));\n        } // We also let rules override the default type of\n        // their parsed node if they would like to, so that\n        // there can be a single output function for all links,\n        // even if there are several rules to parse them.\n\n\n        if (parsed.type == null) {\n          // $FlowFixMe\n          parsed.type = ruleType;\n        }\n\n        result.push(parsed);\n      }\n\n      state.prevCapture = capture;\n      source = source.substring(state.prevCapture[0].length);\n    } // $FlowFixMe\n\n\n    return result;\n  };\n\n  var outerParse = function outerParse(source, state) {\n    latestState = populateInitialState(state, defaultState);\n\n    if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n      source = source + \"\\n\\n\";\n    } // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information). This stores\n    // the full regex capture object, if there is one.\n\n\n    latestState.prevCapture = null;\n    return nestedParse(preprocess(source), latestState);\n  }; // $FlowFixMe\n\n\n  return outerParse;\n}; // Creates a match function for an inline scoped element from a regex\n\n\nvar inlineRegex = function inlineRegex(regex) {\n  var match = function match(source, state, prevCapture) {\n    if (state.inline) {\n      // $FlowFixMe\n      return regex.exec(source);\n    } else {\n      return null;\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function for a block scoped element from a regex\n\n\nvar blockRegex = function blockRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    if (state.inline) {\n      return null;\n    } else {\n      return regex.exec(source);\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function from a regex, ignoring block/inline scope\n\n\nvar anyScopeRegex = function anyScopeRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    return regex.exec(source);\n  };\n\n  match.regex = regex;\n  return match;\n};\n\nvar TYPE_SYMBOL = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n\nvar reactElement = function reactElement(type, key, props) {\n  var element = {\n    $$typeof: TYPE_SYMBOL,\n    type: type,\n    key: key == null ? undefined : key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n  return element;\n};\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\n\n\nvar htmlTag = function htmlTag(tagName, content, attributes, isClosed) {\n  attributes = attributes || {};\n  isClosed = typeof isClosed !== \"undefined\" ? isClosed : true;\n  var attributeString = \"\";\n\n  for (var attr in attributes) {\n    var attribute = attributes[attr]; // Removes falsey attributes\n\n    if ( // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(attributes, attr) && attribute) {\n      attributeString += \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n    }\n  }\n\n  var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n  if (isClosed) {\n    return unclosedTag + content + \"</\" + tagName + \">\";\n  } else {\n    return unclosedTag;\n  }\n};\n\nvar EMPTY_PROPS = {};\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\n\nvar sanitizeUrl = function sanitizeUrl(url) {\n  if (url == null) {\n    return null;\n  }\n\n  try {\n    var prot = new URL(url, \"https://localhost\").protocol;\n\n    if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n      return null;\n    }\n  } catch (e) {\n    // invalid URLs should throw a TypeError\n    // see for instance: `new URL(\"\");`\n    return null;\n  }\n\n  return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"&\": \"&amp;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#x27;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#96;\"\n};\n\nvar sanitizeText = function sanitizeText(text) {\n  return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n    return SANITIZE_TEXT_CODES[chr];\n  });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function unescapeUrl(rawUrlString) {\n  return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n */\n\n\nvar parseInline = function parseInline(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = true;\n  var result = parse(content, state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseBlock = function parseBlock(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = false;\n  var result = parse(content + \"\\n\\n\", state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseCaptureInline = function parseCaptureInline(capture, parse, state) {\n  return {\n    content: parseInline(parse, capture[1], state)\n  };\n};\n\nvar ignoreCapture = function ignoreCapture() {\n  return {};\n}; // recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\n\n\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\"; // recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\n\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX); // recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\n\nvar LIST_ITEM_R = new RegExp(LIST_ITEM_PREFIX + \"[^\\\\n]*(?:\\\\n\" + \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\", \"gm\");\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g; // recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\n\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/; // check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\n\nvar LIST_R = new RegExp(\"^( *)(\" + LIST_BULLET + \") \" + \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" + \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" + // the \\\\s*$ here is so that we can parse the inside of nested\n// lists, where our content might end before we receive two `\\n`s\n\"|\\\\s*\\n*$)\");\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = function () {\n  var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n  var TABLE_CELL_END_TRIM = / *$/;\n  var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n  var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n  var TABLE_LEFT_ALIGN = /^ *:-+ *$/; // TODO: This needs a real type\n\n  var parseTableAlignCapture = function parseTableAlignCapture(alignCapture) {\n    if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n      return \"right\";\n    } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n      return \"center\";\n    } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n      return \"left\";\n    } else {\n      return null;\n    }\n  };\n\n  var parseTableAlign = function parseTableAlign(source, parse, state, trimEndSeparators) {\n    if (trimEndSeparators) {\n      source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n    }\n\n    var alignText = source.trim().split(\"|\");\n    return alignText.map(parseTableAlignCapture);\n  };\n\n  var parseTableRow = function parseTableRow(source, parse, state, trimEndSeparators) {\n    var prevInTable = state.inTable;\n    state.inTable = true;\n    var tableRow = parse(source.trim(), state);\n    state.inTable = prevInTable;\n    var cells = [[]];\n    tableRow.forEach(function (node, i) {\n      if (node.type === \"tableSeparator\") {\n        // Filter out empty table separators at the start/end:\n        if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n          // Split the current row:\n          cells.push([]);\n        }\n      } else {\n        if (node.type === \"text\" && (tableRow[i + 1] == null || tableRow[i + 1].type === \"tableSeparator\")) {\n          node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n        }\n\n        cells[cells.length - 1].push(node);\n      }\n    });\n    return cells;\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {SimpleMarkdown.State} state\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.ASTNode[][]}\n   */\n\n\n  var parseTableCells = function parseTableCells(source, parse, state, trimEndSeparators) {\n    var rowsText = source.trim().split(\"\\n\");\n    return rowsText.map(function (rowText) {\n      // $FlowFixMe\n      return parseTableRow(rowText, parse, state, trimEndSeparators);\n    });\n  };\n  /**\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.SingleNodeParseFunction}\n   */\n\n\n  var parseTable = function parseTable(trimEndSeparators) {\n    return function (capture, parse, state) {\n      state.inline = true;\n      var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n      var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n      var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n      state.inline = false;\n      return {\n        type: \"table\",\n        header: header,\n        align: align,\n        cells: cells\n      };\n    };\n  };\n\n  return {\n    parseTable: parseTable(true),\n    parseNpTable: parseTable(false),\n    TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n    NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n  };\n}();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE = \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function parseRef(capture, state, refNode) {\n  var ref = (capture[2] || capture[1]).replace(/\\s+/g, \" \").toLowerCase(); // We store information about previously seen defs on\n  // state._defs (_ to deconflict with client-defined\n  // state). If the def for this reflink/refimage has\n  // already been seen, we can use its target/source\n  // and title here:\n\n  if (state._defs && state._defs[ref]) {\n    var def = state._defs[ref]; // `refNode` can be a link or an image. Both use\n    // target and title properties.\n\n    refNode.target = def.target;\n    refNode.title = def.title;\n  } // In case we haven't seen our def yet (or if someone\n  // overwrites that def later on), we add this node\n  // to the list of ref nodes for that def. Then, when\n  // we find the def, we can modify this link/image AST\n  // node :).\n  // I'm sorry.\n\n\n  state._refs = state._refs || {};\n  state._refs[ref] = state._refs[ref] || [];\n\n  state._refs[ref].push(refNode);\n\n  return refNode;\n};\n\nvar currOrder = 0;\nvar defaultRules = {\n  Array: {\n    react: function react(arr, output, state) {\n      var oldKey = state.key;\n      var result = []; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0, key = 0; i < arr.length; i++, key++) {\n        // `key` is our numerical `state.key`, which we increment for\n        // every output node, but don't change for joined text nodes.\n        // (i, however, must change for joined text nodes)\n        state.key = \"\" + i;\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result.push(output(node, state));\n      }\n\n      state.key = oldKey;\n      return result;\n    },\n    html: function html(arr, output, state) {\n      var result = \"\"; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0; i < arr.length; i++) {\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result += output(node, state);\n      }\n\n      return result;\n    }\n  },\n  heading: {\n    order: currOrder++,\n    match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n    parse: function (_parse) {\n      function parse(_x, _x2, _x3) {\n        return _parse.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        level: capture[1].length,\n        content: parseInline(parse, capture[2].trim(), state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"h\" + node.level, state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"h\" + node.level, output(node.content, state));\n    }\n  },\n  nptable: {\n    order: currOrder++,\n    match: blockRegex(TABLES.NPTABLE_REGEX),\n    parse: TABLES.parseNpTable,\n    react: null,\n    html: null\n  },\n  lheading: {\n    order: currOrder++,\n    match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n    parse: function (_parse2) {\n      function parse(_x4, _x5, _x6) {\n        return _parse2.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse2.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"heading\",\n        level: capture[2] === \"=\" ? 1 : 2,\n        content: parseInline(parse, capture[1], state)\n      };\n    }),\n    react: null,\n    html: null\n  },\n  hr: {\n    order: currOrder++,\n    match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"hr\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<hr>\";\n    }\n  },\n  codeBlock: {\n    order: currOrder++,\n    match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n    parse: function (_parse3) {\n      function parse(_x7, _x8, _x9) {\n        return _parse3.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse3.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^    /gm, \"\").replace(/\\n+$/, \"\");\n      return {\n        lang: undefined,\n        content: content\n      };\n    }),\n    react: function react(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      return reactElement(\"pre\", state.key, {\n        children: reactElement(\"code\", null, {\n          className: className,\n          children: node.content\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n        class: className\n      });\n      return htmlTag(\"pre\", codeBlock);\n    }\n  },\n  fence: {\n    order: currOrder++,\n    match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n    parse: function (_parse4) {\n      function parse(_x10, _x11, _x12) {\n        return _parse4.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse4.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"codeBlock\",\n        lang: capture[2] || undefined,\n        content: capture[3]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  blockQuote: {\n    order: currOrder++,\n    match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n    parse: function (_parse5) {\n      function parse(_x13, _x14, _x15) {\n        return _parse5.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse5.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^ *> ?/gm, \"\");\n      return {\n        content: parse(content, state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"blockquote\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"blockquote\", output(node.content, state));\n    }\n  },\n  list: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      // We only want to break into a list if we are at the start of a\n      // line. This is to avoid parsing \"hi * there\" with \"* there\"\n      // becoming a part of a list.\n      // You might wonder, \"but that's inline, so of course it wouldn't\n      // start a list?\". You would be correct! Except that some of our\n      // lists can be inline, because they might be inside another list,\n      // in which case we can parse with inline scope, but need to allow\n      // nested lists inside this inline scope.\n      var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n      var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n      var isListBlock = state._list || !state.inline;\n\n      if (isStartOfLineCapture && isListBlock) {\n        source = isStartOfLineCapture[1] + source;\n        return LIST_R.exec(source);\n      } else {\n        return null;\n      }\n    },\n    parse: function (_parse6) {\n      function parse(_x16, _x17, _x18) {\n        return _parse6.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse6.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var bullet = capture[2];\n      var ordered = bullet.length > 1;\n      var start = ordered ? +bullet : undefined;\n      var items = capture[0].replace(LIST_BLOCK_END_R, \"\\n\").match(LIST_ITEM_R); // We know this will match here, because of how the regexes are\n      // defined\n\n      var lastItemWasAParagraph = false;\n      var itemContent = items.map(function (item, i) {\n        // We need to see how far indented this item is:\n        var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n        var space = prefixCapture ? prefixCapture[0].length : 0; // And then we construct a regex to \"unindent\" the subsequent\n        // lines of the items by that amount:\n\n        var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\"); // Before processing the item, we need a couple things\n\n        var content = item // remove indents on trailing lines:\n        .replace(spaceRegex, \"\") // remove the bullet:\n        .replace(LIST_ITEM_PREFIX_R, \"\"); // I'm not sur4 why this is necessary again?\n        // Handling \"loose\" lists, like:\n        //\n        //  * this is wrapped in a paragraph\n        //\n        //  * as is this\n        //\n        //  * as is this\n\n        var isLastItem = i === items.length - 1;\n        var containsBlocks = content.indexOf(\"\\n\\n\") !== -1; // Any element in a list is a block if it contains multiple\n        // newlines. The last element in the list can also be a block\n        // if the previous item in the list was a block (this is\n        // because non-last items in the list can end with \\n\\n, but\n        // the last item can't, so we just \"inherit\" this property\n        // from our previous element).\n\n        var thisItemIsAParagraph = containsBlocks || isLastItem && lastItemWasAParagraph;\n        lastItemWasAParagraph = thisItemIsAParagraph; // backup our state for restoration afterwards. We're going to\n        // want to set state._list to true, and state.inline depending\n        // on our list's looseness.\n\n        var oldStateInline = state.inline;\n        var oldStateList = state._list;\n        state._list = true; // Parse inline if we're in a tight list, or block if we're in\n        // a loose list.\n\n        var adjustedContent;\n\n        if (thisItemIsAParagraph) {\n          state.inline = false;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n        } else {\n          state.inline = true;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n        }\n\n        var result = parse(adjustedContent, state); // Restore our state before returning\n\n        state.inline = oldStateInline;\n        state._list = oldStateList;\n        return result;\n      });\n      return {\n        ordered: ordered,\n        start: start,\n        items: itemContent\n      };\n    }),\n    react: function react(node, output, state) {\n      var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n      return reactElement(ListWrapper, state.key, {\n        start: node.start,\n        children: node.items.map(function (item, i) {\n          return reactElement(\"li\", \"\" + i, {\n            children: output(item, state)\n          });\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var listItems = node.items.map(function (item) {\n        return htmlTag(\"li\", output(item, state));\n      }).join(\"\");\n      var listTag = node.ordered ? \"ol\" : \"ul\";\n      var attributes = {\n        start: node.start\n      };\n      return htmlTag(listTag, listItems, attributes);\n    }\n  },\n  def: {\n    order: currOrder++,\n    // TODO(aria): This will match without a blank line before the next\n    // block element, which is inconsistent with most of the rest of\n    // simple-markdown.\n    match: blockRegex(/^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/),\n    parse: function (_parse7) {\n      function parse(_x19, _x20, _x21) {\n        return _parse7.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse7.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var def = capture[1].replace(/\\s+/g, \" \").toLowerCase();\n      var target = capture[2];\n      var title = capture[3]; // Look for previous links/images using this def\n      // If any links/images using this def have already been declared,\n      // they will have added themselves to the state._refs[def] list\n      // (_ to deconflict with client-defined state). We look through\n      // that list of reflinks for this def, and modify those AST nodes\n      // with our newly found information now.\n      // Sorry :(.\n\n      if (state._refs && state._refs[def]) {\n        // `refNode` can be a link or an image\n        state._refs[def].forEach(function (refNode) {\n          refNode.target = target;\n          refNode.title = title;\n        });\n      } // Add this def to our map of defs for any future links/images\n      // In case we haven't found any or all of the refs referring to\n      // this def yet, we add our def to the table of known defs, so\n      // that future reflinks can modify themselves appropriately with\n      // this information.\n\n\n      state._defs = state._defs || {};\n      state._defs[def] = {\n        target: target,\n        title: title\n      }; // return the relevant parsed information\n      // for debugging only.\n\n      return {\n        def: def,\n        target: target,\n        title: title\n      };\n    }),\n    react: function react() {\n      return null;\n    },\n    html: function html() {\n      return \"\";\n    }\n  },\n  table: {\n    order: currOrder++,\n    match: blockRegex(TABLES.TABLE_REGEX),\n    parse: TABLES.parseTable,\n    react: function react(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? {} : {\n          textAlign: node.align[colIndex]\n        };\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return reactElement(\"th\", \"\" + i, {\n          style: getStyle(i),\n          scope: \"col\",\n          children: output(content, state)\n        });\n      });\n      var rows = node.cells.map(function (row, r) {\n        return reactElement(\"tr\", \"\" + r, {\n          children: row.map(function (content, c) {\n            return reactElement(\"td\", \"\" + c, {\n              style: getStyle(c),\n              children: output(content, state)\n            });\n          })\n        });\n      });\n      return reactElement(\"table\", state.key, {\n        children: [reactElement(\"thead\", \"thead\", {\n          children: reactElement(\"tr\", null, {\n            children: headers\n          })\n        }), reactElement(\"tbody\", \"tbody\", {\n          children: rows\n        })]\n      });\n    },\n    html: function html(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? \"\" : \"text-align:\" + node.align[colIndex] + \";\";\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return htmlTag(\"th\", output(content, state), {\n          style: getStyle(i),\n          scope: \"col\"\n        });\n      }).join(\"\");\n      var rows = node.cells.map(function (row) {\n        var cols = row.map(function (content, c) {\n          return htmlTag(\"td\", output(content, state), {\n            style: getStyle(c)\n          });\n        }).join(\"\");\n        return htmlTag(\"tr\", cols);\n      }).join(\"\");\n      var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n      var tbody = htmlTag(\"tbody\", rows);\n      return htmlTag(\"table\", thead + tbody);\n    }\n  },\n  newline: {\n    order: currOrder++,\n    match: blockRegex(/^(?:\\n *)*\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return \"\\n\";\n    },\n    html: function html(node, output, state) {\n      return \"\\n\";\n    }\n  },\n  paragraph: {\n    order: currOrder++,\n    match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"div\", state.key, {\n        className: \"paragraph\",\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        class: \"paragraph\"\n      };\n      return htmlTag(\"div\", output(node.content, state), attributes);\n    }\n  },\n  escape: {\n    order: currOrder++,\n    // We don't allow escaping numbers, letters, or spaces here so that\n    // backslashes used in plain text still get rendered. But allowing\n    // escaping anything else provides a very flexible escape mechanism,\n    // regardless of how this grammar is extended.\n    match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n    parse: function (_parse8) {\n      function parse(_x22, _x23, _x24) {\n        return _parse8.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse8.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"text\",\n        content: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  tableSeparator: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      if (!state.inTable) {\n        return null;\n      }\n\n      return /^ *\\| */.exec(source);\n    },\n    parse: function parse() {\n      return {\n        type: \"tableSeparator\"\n      };\n    },\n    // These shouldn't be reached, but in case they are, be reasonable:\n    react: function react() {\n      return \" | \";\n    },\n    html: function html() {\n      return \" &vert; \";\n    }\n  },\n  autolink: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n    parse: function (_parse9) {\n      function parse(_x25, _x26, _x27) {\n        return _parse9.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse9.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  mailto: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n    parse: function (_parse10) {\n      function parse(_x28, _x29, _x30) {\n        return _parse10.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse10.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var address = capture[1];\n      var target = capture[1]; // Check for a `mailto:` already existing in the link:\n\n      if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n        target = \"mailto:\" + target;\n      }\n\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: address\n        }],\n        target: target\n      };\n    }),\n    react: null,\n    html: null\n  },\n  url: {\n    order: currOrder++,\n    match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n    parse: function (_parse11) {\n      function parse(_x31, _x32, _x33) {\n        return _parse11.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse11.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1],\n        title: undefined\n      };\n    }),\n    react: null,\n    html: null\n  },\n  link: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse12) {\n      function parse(_x34, _x35, _x36) {\n        return _parse12.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse12.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var link = {\n        content: parse(capture[1], state),\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return link;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"a\", state.key, {\n        href: sanitizeUrl(node.target),\n        title: node.title,\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        href: sanitizeUrl(node.target),\n        title: node.title\n      };\n      return htmlTag(\"a\", output(node.content, state), attributes);\n    }\n  },\n  image: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse13) {\n      function parse(_x37, _x38, _x39) {\n        return _parse13.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse13.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var image = {\n        alt: capture[1],\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return image;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"img\", state.key, {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      };\n      return htmlTag(\"img\", \"\", attributes, false);\n    }\n  },\n  reflink: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse14) {\n      function parse(_x40, _x41, _x42) {\n        return _parse14.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse14.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"link\",\n        content: parse(capture[1], state)\n      });\n    }),\n    react: null,\n    html: null\n  },\n  refimage: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse15) {\n      function parse(_x43, _x44, _x45) {\n        return _parse15.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse15.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"image\",\n        alt: capture[1]\n      });\n    }),\n    react: null,\n    html: null\n  },\n  em: {\n    order: currOrder\n    /* same as strong/u */\n    ,\n    match: inlineRegex(new RegExp( // only match _s surrounding words.\n    \"^\\\\b_\" + \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" + \"\\\\b\" + // Or match *s:\n    \"|\" + // Only match *s that are followed by a non-space:\n    \"^\\\\*(?=\\\\S)(\" + // Match at least one of:\n    \"(?:\" + //  - `**`: so that bolds inside italics don't close the\n    //          italics\n    \"\\\\*\\\\*|\" + //  - escape sequence: so escaped *s don't close us\n    \"\\\\\\\\[\\\\s\\\\S]|\" + //  - whitespace: followed by a non-* (we don't\n    //          want ' *' to close an italics--it might\n    //          start a list)\n    \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" + //  - non-whitespace, non-*, non-backslash characters\n    \"[^\\\\s\\\\*\\\\\\\\]\" + \")+?\" + // followed by a non-space, non-* then *\n    \")\\\\*(?!\\\\*)\")),\n    quality: function quality(capture) {\n      // precedence by length, `em` wins ties:\n      return capture[0].length + 0.2;\n    },\n    parse: function (_parse16) {\n      function parse(_x46, _x47, _x48) {\n        return _parse16.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse16.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: parse(capture[2] || capture[1], state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"em\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"em\", output(node.content, state));\n    }\n  },\n  strong: {\n    order: currOrder\n    /* same as em */\n    ,\n    match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n    quality: function quality(capture) {\n      // precedence by length, wins ties vs `u`:\n      return capture[0].length + 0.1;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"strong\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"strong\", output(node.content, state));\n    }\n  },\n  u: {\n    order: currOrder++\n    /* same as em&strong; increment for next rule */\n    ,\n    match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n    quality: function quality(capture) {\n      // precedence by length, loses all ties\n      return capture[0].length;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"u\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"u\", output(node.content, state));\n    }\n  },\n  del: {\n    order: currOrder++,\n    match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"del\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"del\", output(node.content, state));\n    }\n  },\n  inlineCode: {\n    order: currOrder++,\n    match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n    parse: function (_parse17) {\n      function parse(_x49, _x50, _x51) {\n        return _parse17.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse17.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"code\", state.key, {\n        children: node.content\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"code\", sanitizeText(node.content));\n    }\n  },\n  br: {\n    order: currOrder++,\n    match: anyScopeRegex(/^ {2,}\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"br\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<br>\";\n    }\n  },\n  text: {\n    order: currOrder++,\n    // Here we look for anything followed by non-symbols,\n    // double newlines, or double-space-newlines\n    // We break on any symbol characters so that this grammar\n    // is easy to extend without needing to modify this regex\n    match: anyScopeRegex(/^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/),\n    parse: function (_parse18) {\n      function parse(_x52, _x53, _x54) {\n        return _parse18.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse18.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[0]\n      };\n    }),\n    react: function react(node, output, state) {\n      return node.content;\n    },\n    html: function html(node, output, state) {\n      return sanitizeText(node.content);\n    }\n  }\n};\n/** (deprecated) */\n\nvar ruleOutput = function ruleOutput( // $FlowFixMe\nrules, property) {\n  if (!property && typeof console !== \"undefined\") {\n    console.warn(\"simple-markdown ruleOutput should take 'react' or \" + \"'html' as the second argument.\");\n  }\n\n  var nestedRuleOutput = function nestedRuleOutput(ast, outputFunc, state) {\n    return rules[ast.type][property](ast, outputFunc, state);\n  };\n\n  return nestedRuleOutput;\n};\n/** (deprecated)\n */\n\n\nvar reactFor = function reactFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      var oldKey = state.key;\n      var result = []; // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n\n      var lastResult = null;\n\n      for (var i = 0; i < ast.length; i++) {\n        state.key = \"\" + i;\n        var nodeOut = nestedOutput(ast[i], state);\n\n        if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n          lastResult = lastResult + nodeOut;\n          result[result.length - 1] = lastResult;\n        } else {\n          result.push(nodeOut);\n          lastResult = nodeOut;\n        }\n      }\n\n      state.key = oldKey;\n      return result;\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n/** (deprecated)\n */\n\n\nvar htmlFor = function htmlFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      return ast.map(function (node) {\n        return nestedOutput(node, state);\n      }).join(\"\");\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n\nvar outputFor = function outputFor(rules, property) {\n  var defaultState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!property) {\n    throw new Error(\"simple-markdown: outputFor: `property` must be \" + \"defined. \" + \"if you just upgraded, you probably need to replace `outputFor` \" + \"with `reactFor`\");\n  }\n\n  var latestState; // $FlowFixMe[incompatible-type]\n\n  var arrayRule = rules.Array || defaultRules.Array; // Tricks to convince tsc that this var is not null:\n\n  var arrayRuleCheck = arrayRule[property];\n\n  if (!arrayRuleCheck) {\n    throw new Error(\"simple-markdown: outputFor: to join nodes of type `\" + property + \"` you must provide an `Array:` joiner rule with that type, \" + \"Please see the docs for details on specifying an Array rule.\");\n  }\n\n  var arrayRuleOutput = arrayRuleCheck;\n\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || latestState;\n    latestState = state;\n\n    if (Array.isArray(ast)) {\n      return arrayRuleOutput(ast, nestedOutput, state);\n    } else {\n      return rules[ast.type][property](ast, nestedOutput, state);\n    }\n  };\n\n  var outerOutput = function outerOutput(ast, state) {\n    latestState = populateInitialState(state, defaultState);\n    return nestedOutput(ast, latestState);\n  };\n\n  return outerOutput;\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultRawParse = parserFor(defaultRules);\n\nvar defaultBlockParse = function defaultBlockParse(source, state) {\n  state = state || {};\n  state.inline = false;\n  return defaultRawParse(source, state);\n};\n\nvar defaultInlineParse = function defaultInlineParse(source, state) {\n  state = state || {};\n  state.inline = true;\n  return defaultRawParse(source, state);\n};\n\nvar defaultImplicitParse = function defaultImplicitParse(source, state) {\n  var isBlock = BLOCK_END_R.test(source);\n  state = state || {};\n  state.inline = !isBlock;\n  return defaultRawParse(source, state);\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultReactOutput = outputFor(defaultRules, \"react\"); // $FlowFixMe[incompatible-call]\n\nvar defaultHtmlOutput = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function markdownToReact(source, state) {\n  return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n\nvar markdownToHtml = function markdownToHtml(source, state) {\n  return defaultHtmlOutput(defaultBlockParse(source, state), state);\n}; // TODO: This needs definition\n\n\nvar ReactMarkdown = function ReactMarkdown(props) {\n  var divProps = {};\n\n  for (var prop in props) {\n    if (prop !== \"source\" && // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(props, prop)) {\n      divProps[prop] = props[prop];\n    }\n  }\n\n  divProps.children = markdownToReact(props.source);\n  return reactElement(\"div\", null, divProps);\n};\n\n// $FlowFixMe\nvar SimpleMarkdown = {\n  defaultRules: defaultRules,\n  parserFor: parserFor,\n  outputFor: outputFor,\n  inlineRegex: inlineRegex,\n  blockRegex: blockRegex,\n  anyScopeRegex: anyScopeRegex,\n  parseInline: parseInline,\n  parseBlock: parseBlock,\n  // default wrappers:\n  markdownToReact: markdownToReact,\n  markdownToHtml: markdownToHtml,\n  ReactMarkdown: ReactMarkdown,\n  defaultBlockParse: defaultBlockParse,\n  defaultInlineParse: defaultInlineParse,\n  defaultImplicitParse: defaultImplicitParse,\n  defaultReactOutput: defaultReactOutput,\n  defaultHtmlOutput: defaultHtmlOutput,\n  preprocess: preprocess,\n  sanitizeText: sanitizeText,\n  sanitizeUrl: sanitizeUrl,\n  unescapeUrl: unescapeUrl,\n  htmlTag: htmlTag,\n  reactElement: reactElement,\n  // deprecated:\n  defaultRawParse: defaultRawParse,\n  ruleOutput: ruleOutput,\n  reactFor: reactFor,\n  htmlFor: htmlFor,\n  defaultParse: function defaultParse() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultParse is deprecated, please use `defaultImplicitParse`\");\n    }\n\n    return defaultImplicitParse.apply(null, arguments);\n  },\n  defaultOutput: function defaultOutput() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultOutput is deprecated, please use `defaultReactOutput`\");\n    }\n\n    return defaultReactOutput.apply(null, arguments);\n  }\n};\n\nexport { SimpleMarkdown as default };\n//# sourceMappingURL=index.js.map\n","import SimpleMarkdown from '@khanacademy/simple-markdown';\n\n/**\n *\n * @param markdown\n */\nfunction preprocessMarkdown(markdown) {\n  // Replace multiple newlines with a single newline\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, '\\n');\n  // Remove extra spaces at the beginning of each line\n  const withoutExtraSpaces = withoutMultipleNewlines.replace(/^\\s+/gm, '');\n  return withoutExtraSpaces;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(preprocessedMarkdown);\n\n  let lines = [[]];\n  let currentLine = 0;\n\n  /**\n   *\n   * @param node\n   * @param parentType\n   */\n  function processNode(node, parentType) {\n    if (node.type === 'text') {\n      const textLines = node.content.split('\\n');\n\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n\n        // textLine.split(/ (?=[^!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]+)/).forEach((word) => {\n        textLine.split(' ').forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType || 'normal' });\n          }\n        });\n      });\n    } else if (node.type === 'strong' || node.type === 'em') {\n      node.content.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n\n  syntaxTree.forEach((treeNode) => {\n    if (treeNode.type === 'paragraph') {\n      treeNode.content.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n\n  return lines;\n}\n\n/**\n *\n * @param markdown\n */\nexport function markdownToHTML(markdown) {\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(markdown);\n\n  /**\n   *\n   * @param node\n   */\n  function output(node) {\n    if (node.type === 'text') {\n      return node.content.replace(/\\n/g, '<br/>');\n    } else if (node.type === 'strong') {\n      return `<strong>${node.content.map(output).join('')}</strong>`;\n    } else if (node.type === 'em') {\n      return `<em>${node.content.map(output).join('')}</em>`;\n    } else if (node.type === 'paragraph') {\n      return `<p>${node.content.map(output).join('')}</p>`;\n    } else {\n      return '';\n    }\n  }\n\n  return syntaxTree.map(output).join('');\n}\n","import { select } from 'd3';\nimport { log } from '../logger';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\nimport { decodeEntities } from '../mermaidAPI';\nimport { markdownToHTML, markdownToLines } from '../rendering-util/handle-markdown-text';\n/**\n * @param dom\n * @param styleFn\n */\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr('style', styleFn);\n  }\n}\n\n/**\n * @param element\n * @param {any} node\n * @param width\n * @param classes\n * @returns {SVGForeignObjectElement} Node\n */\nfunction addHtmlSpan(element, node, width, classes) {\n  const fo = element.append('foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  // const newEl = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n  const div = fo.append('xhtml:div');\n  // const div = body.append('div');\n  // const div = fo.append('div');\n\n  const label = node.label;\n  const labelClass = node.isNode ? 'nodeLabel' : 'edgeLabel';\n  div.html(\n    `<span class=\"${labelClass} ${classes}\" ` +\n      (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : '') +\n      '>' +\n      label +\n      '</span>'\n  );\n\n  applyStyle(div, node.labelStyle);\n  div.style('display', 'table-cell');\n  div.style('white-space', 'nowrap');\n  div.style('max-width', width + 'px');\n  div.attr('xmlns', 'http://www.w3.org/1999/xhtml');\n\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style('display', 'table');\n    div.style('white-space', 'break-spaces');\n    div.style('width', width + 'px');\n    bbox = div.node().getBoundingClientRect();\n  }\n\n  fo.style('width', bbox.width);\n  fo.style('height', bbox.height);\n\n  return fo.node();\n}\n\n/**\n * Creates a tspan element with the specified attributes for text positioning.\n *\n * @param {object} textElement - The parent text element to append the tspan element.\n * @param {number} lineIndex - The index of the current line in the structuredText array.\n * @param {number} lineHeight - The line height value for the text.\n * @returns {object} The created tspan element.\n */\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement\n    .append('tspan')\n    .attr('class', 'text-outer-tspan')\n    .attr('x', 0)\n    .attr('y', lineIndex * lineHeight - 0.1 + 'em')\n    .attr('dy', lineHeight + 'em');\n}\n\n/**\n * Creates a formatted text element by breaking lines and applying styles based on\n * the given structuredText.\n *\n * @param {number} width - The maximum allowed width of the text.\n * @param {object} g - The parent group element to append the formatted text.\n * @param {Array} structuredText - The structured text data to format.\n * @param addBackground\n */\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append('g');\n  let bkg = labelGroup.insert('rect').attr('class', 'background');\n  const textElement = labelGroup.append('text').attr('y', '-10.1');\n  // .attr('dominant-baseline', 'middle')\n  // .attr('text-anchor', 'middle');\n  // .attr('text-anchor', 'middle');\n  let lineIndex = -1;\n  structuredText.forEach((line) => {\n    lineIndex++;\n    let tspan = createTspan(textElement, lineIndex, lineHeight);\n\n    let words = [...line].reverse();\n    let currentWord;\n    let wrappedLine = [];\n\n    while (words.length) {\n      currentWord = words.pop();\n      wrappedLine.push(currentWord);\n\n      updateTextContentAndStyles(tspan, wrappedLine);\n\n      if (tspan.node().getComputedTextLength() > width) {\n        wrappedLine.pop();\n        words.push(currentWord);\n\n        updateTextContentAndStyles(tspan, wrappedLine);\n\n        wrappedLine = [];\n        lineIndex++;\n        tspan = createTspan(textElement, lineIndex, lineHeight);\n      }\n    }\n  });\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg\n      .attr('x', -padding)\n      .attr('y', -padding)\n      .attr('width', bbox.width + 2 * padding)\n      .attr('height', bbox.height + 2 * padding);\n    // .style('fill', 'red');\n\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n\n/**\n * Updates the text content and styles of the given tspan element based on the\n * provided wrappedLine data.\n *\n * @param {object} tspan - The tspan element to update.\n * @param {Array} wrappedLine - The line data to apply to the tspan element.\n */\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text('');\n\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan\n      .append('tspan')\n      .attr('font-style', word.type === 'em' ? 'italic' : 'normal')\n      .attr('class', 'text-inner-tspan')\n      .attr('font-weight', word.type === 'strong' ? 'bold' : 'normal');\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(' ' + word.content);\n    }\n  });\n}\n\n/**\n *\n * @param el\n * @param {*} text\n * @param {*} param1\n * @param root0\n * @param root0.style\n * @param root0.isTitle\n * @param root0.classes\n * @param root0.useHtmlLabels\n * @param root0.isNode\n * @returns\n */\n// Note when using from flowcharts converting the API isNode means classes should be set accordingly. When using htmlLabels => to sett classes to'nodeLabel' when isNode=true otherwise 'edgeLabel'\n// When not using htmlLabels => to set classes to 'title-row' when isTitle=true otherwise 'title-row'\nexport const createText = (\n  el,\n  text = '',\n  {\n    style = '',\n    isTitle = false,\n    classes = '',\n    useHtmlLabels = true,\n    isNode = true,\n    width,\n    addSvgBackground = false,\n  } = {}\n) => {\n  log.info('createText', text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n    // text = text.replace(/\\\\n|\\n/g, '<br />');\n    const htmlText = markdownToHTML(text);\n    // log.info('markdo  wnToHTML' + text, markdownToHTML(text));\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(':', ' ')}'></i>`\n      ),\n      labelStyle: style.replace('fill:', 'color:'),\n    };\n    let vertexNode = addHtmlSpan(el, node, width, classes);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const special = ['\"', \"'\", '.', ',', ':', ';', '!', '?', '(', ')', '[', ']', '{', '}'];\n    let lastWord;\n    structuredText.forEach((line) => {\n      line.forEach((word) => {\n        if (special.includes(word.content) && lastWord) {\n          lastWord.content += word.content;\n          word.content = '';\n        }\n        lastWord = word;\n      });\n    });\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\n"],"names":["CR_NEWLINE_R","TAB_R","FORMFEED_R","preprocess","source","populateInitialState","givenState","defaultState","state","prop","parserFor","rules","ruleList","type","rule","order","typeA","typeB","ruleA","ruleB","orderA","orderB","secondaryOrderA","secondaryOrderB","latestState","nestedParse","result","ruleType","capture","quality","i","currRuleType","currRule","currOrder","prevCaptureStr","currCapture","currQuality","parsed","outerParse","inlineRegex","regex","match","prevCapture","blockRegex","anyScopeRegex","TYPE_SYMBOL","reactElement","key","props","element","htmlTag","tagName","content","attributes","isClosed","attributeString","attr","attribute","sanitizeText","unclosedTag","EMPTY_PROPS","sanitizeUrl","url","prot","SANITIZE_TEXT_R","SANITIZE_TEXT_CODES","text","chr","UNESCAPE_URL_R","unescapeUrl","rawUrlString","parseInline","parse","isCurrentlyInline","parseBlock","parseCaptureInline","ignoreCapture","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","LIST_ITEM_R","BLOCK_END_R","INLINE_CODE_ESCAPE_BACKTICKS_R","LIST_BLOCK_END_R","LIST_ITEM_END_R","LIST_R","LIST_LOOKBEHIND_R","TABLES","TABLE_ROW_SEPARATOR_TRIM","TABLE_CELL_END_TRIM","TABLE_RIGHT_ALIGN","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","parseTableAlignCapture","alignCapture","parseTableAlign","trimEndSeparators","alignText","parseTableRow","prevInTable","tableRow","cells","node","parseTableCells","rowsText","rowText","parseTable","header","align","LINK_INSIDE","LINK_HREF_AND_TITLE","AUTOLINK_MAILTO_CHECK_R","parseRef","refNode","ref","def","defaultRules","arr","output","oldKey","_parse","_x","_x2","_x3","_parse2","_x4","_x5","_x6","_parse3","_x7","_x8","_x9","className","codeBlock","_parse4","_x10","_x11","_x12","_parse5","_x13","_x14","_x15","isStartOfLineCapture","isListBlock","_parse6","_x16","_x17","_x18","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","item","prefixCapture","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","ListWrapper","listItems","listTag","_parse7","_x19","_x20","_x21","target","title","getStyle","colIndex","headers","rows","row","r","c","cols","thead","tbody","_parse8","_x22","_x23","_x24","_parse9","_x25","_x26","_x27","_parse10","_x28","_x29","_x30","address","_parse11","_x31","_x32","_x33","_parse12","_x34","_x35","_x36","link","_parse13","_x37","_x38","_x39","image","_parse14","_x40","_x41","_x42","_parse15","_x43","_x44","_x45","_parse16","_x46","_x47","_x48","_parse17","_x49","_x50","_x51","_parse18","_x52","_x53","_x54","ruleOutput","property","nestedRuleOutput","ast","outputFunc","reactFor","nestedOutput","lastResult","nodeOut","htmlFor","outputFor","arrayRule","arrayRuleCheck","arrayRuleOutput","outerOutput","defaultRawParse","defaultBlockParse","defaultInlineParse","defaultImplicitParse","isBlock","defaultReactOutput","defaultHtmlOutput","markdownToReact","markdownToHtml","ReactMarkdown","divProps","SimpleMarkdown","preprocessMarkdown","markdown","markdownToLines","preprocessedMarkdown","mdParse","syntaxTree","lines","currentLine","processNode","parentType","textLine","index","word","contentNode","treeNode","markdownToHTML","applyStyle","dom","styleFn","addHtmlSpan","width","classes","fo","div","label","labelClass","bbox","createTspan","textElement","lineIndex","lineHeight","createFormattedText","g","structuredText","addBackground","labelGroup","bkg","line","tspan","words","currentWord","wrappedLine","updateTextContentAndStyles","padding","innerTspan","createText","el","style","isTitle","useHtmlLabels","isNode","addSvgBackground","log","htmlText","decodeEntities","s","special","lastWord"],"mappings":"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"}